<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring AOP理解</title>
      <link href="2021/01/01/Spring%20AOP%E7%90%86%E8%A7%A3/"/>
      <url>2021/01/01/Spring%20AOP%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。 </p><h4 id="1-我所知道的aop"><a href="#1-我所知道的aop" class="headerlink" title="1.我所知道的aop"></a>1.我所知道的aop</h4><p>　　初看aop,上来就是一大堆术语，而且还有个拉风的名字，面向切面编程，都说是OOP的一种有益补充等等。一下子让你不知所措，心想着：怪不得很多人都和我说aop多难多难。当我看进去以后，我才发现：它就是一些java基础上的朴实无华的应用，包括ioc，包括许许多多这样的名词，都是万变不离其宗而已。</p><h4 id="2-为什么用aop"><a href="#2-为什么用aop" class="headerlink" title="2.为什么用aop"></a>2.为什么用aop</h4><ol><li><p>就是为了方便，看一个国外很有名的大师说，编程的人都是“懒人”，因为他把自己做的事情都让程序做了。用了aop能让你少写很多代码，这点就够充分了吧</p></li><li><p>就是为了更清晰的逻辑，可以让你的业务逻辑去关注自己本身的业务，而不去想一些其他的事情，这些其他的事情包括：安全，事物，日志等。</p></li></ol><h4 id="3-那些aop的术语"><a href="#3-那些aop的术语" class="headerlink" title="3.那些aop的术语"></a>3.那些aop的术语</h4><p>　　初看这么多术语，一下子都不好接受，慢慢来，很快就会搞懂。</p><ul><li><p>1.通知（Advice）<br>　　就是你想要的功能，也就是上面说的 安全，事物，日志等。你给先定义好把，然后在想用的地方用一下。</p></li><li><p> 2.连接点（JoinPoint）<br>　　这个更好解释了，就是spring允许你使用通知的地方，那可真就多了，基本每个方法的前，后（两者都有也行），或抛出异常时都可以是连接点，spring只支持方法连接点.其他如aspectJ还可以让你在构造器或属性注入时都行，不过那不是咱关注的，只要记住，和方法有关的前前后后（抛出异常），都是连接点。</p></li><li><p>3.切入点（Pointcut）<br>　　上面说的连接点的基础上，来定义切入点，你的一个类里，有15个方法，那就有几十个连接点了对把，但是你并不想在所有方法附近都使用通知（使用叫织入，以后再说），你只想让其中的几个，在调用这几个方法之前，之后或者抛出异常时干点什么，那么就用切点来定义这几个方法，让切点来筛选连接点，选中那几个你想要的方法。</p></li><li><p>4.切面（Aspect）<br>　　切面是通知和切入点的结合。现在发现了吧，没连接点什么事情，连接点就是为了让你好理解切点，搞出来的，明白这个概念就行了。通知说明了干什么和什么时候干（什么时候通过方法名中的before,after，around等就能知道），而切入点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义。</p></li><li><p>5.引入（introduction）<br>　　允许我们向现有的类添加新方法属性。这不就是把切面（也就是新方法属性：通知定义的）用到目标类中吗</p></li><li><p>6.目标（target）<br>　　引入中所提到的目标类，也就是要被通知的对象，也就是真正的业务逻辑，他可以在毫不知情的情况下，被咱们织入切面。而自己专注于业务本身的逻辑。</p></li><li><p>7.代理(proxy)<br>　　怎么实现整套aop机制的，都是通过代理，这个一会给细说。</p></li><li><p>8.织入(weaving)<br>　　把切面应用到目标对象来创建新的代理对象的过程。有3种方式，spring采用的是运行时，为什么是运行时，后面解释。</p></li></ul><p>　　关键就是：切点定义了哪些连接点会得到通知</p><h4 id="4-我所理解的aop原理"><a href="#4-我所理解的aop原理" class="headerlink" title="4.我所理解的aop原理"></a>4.我所理解的aop原理</h4><p>　　spring用代理类包裹切面，把他们织入到Spring管理的bean中。也就是说代理类伪装成目标类，它会截取对目标类中方法的调用，让调用者对目标类的调用都先变成调用伪装类，伪装类中就先执行了切面，再把调用转发给真正的目标bean。</p><p>　　现在可以自己想一想，怎么搞出来这个伪装类，才不会被调用者发现（过JVM的检查，JAVA是强类型检查，哪里都要检查类型）。</p><ul><li>1.实现和目标类相同的接口，我也实现和你一样的接口，反正上层都是接口级别的调用，这样我就伪装成了和目标类一样的类（实现了同一接口，咱是兄弟了），也就逃过了类型检查，到java运行期的时候，利用多态的后期绑定（所以spring采用运行时），伪装类（代理类）就变成了接口的真正实现，而他里面包裹了真实的那个目标类，最后实现具体功能的还是目标类，只不过伪装类在之前干了点事情（写日志，安全检查，事物等）。</li></ul><p>　　这就好比，一个人让你办件事，每次这个时候，你弟弟就会先出来，当然他分不出来了，以为是你，你这个弟弟虽然办不了这事，但是他知道你能办，所以就答应下来了，并且收了点礼物（写日志），收完礼物了，给把事给人家办了啊，所以你弟弟又找你这个哥哥来了，最后把这是办了的还是你自己。但是你自己并不知道你弟弟已经收礼物了，你只是专心把这件事情做好。</p><p>　　顺着这个思路想，要是本身这个类就没实现一个接口呢，你怎么伪装我，我就压根没有机会让你搞出这个双胞胎的弟弟，那么就用第2种代理方式，创建一个目标类的子类，生个儿子，让儿子伪装我</p><ul><li>2.生成子类调用，这次用子类来做为伪装类，当然这样也能逃过JVM的强类型检查，我继承的吗，当然查不出来了，子类重写了目标类的所有方法，当然在这些重写的方法中，不仅实现了目标类的功能，还在这些功能之前，实现了一些其他的（写日志，安全检查，事物等）。</li></ul><p>　　这次的对比就是，儿子先从爸爸那把本事都学会了，所有人都找儿子办事情，但是儿子每次办和爸爸同样的事之前，都要收点小礼物（写日志），然后才去办真正的事。当然爸爸是不知道儿子这么干的了。这里就有件事情要说，某些本事是爸爸独有的(final的)，儿子学不了，学不了就办不了这件事，办不了这个事情，自然就不能收人家礼了。</p><p>　　前一种兄弟模式，spring会使用JDK的java.lang.reflect.Proxy类，它允许Spring动态生成一个新类来实现必要的接口，织入通知，并且把对这些接口的任何调用都转发到目标类。</p><p>　　后一种父子模式，spring使用CGLIB库生成目标类的一个子类，在创建这个子类的时候，spring织入通知，并且把对这个子类的调用委托到目标类。</p><p>　　相比之下，还是兄弟模式好些，他能更好的实现松耦合，尤其在今天都高喊着面向接口编程的情况下，父子模式只是在没有实现接口的时候，也能织入通知，应当做一种例外。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring IOC理解</title>
      <link href="2020/12/20/Spring%20IOC%E7%90%86%E8%A7%A3/"/>
      <url>2020/12/20/Spring%20IOC%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>学习过Spring框架的人一定都会听过Spring的IoC(控制反转) 、DI(依赖注入)这两个概念，对于初学Spring的人来说，总觉得IoC 、DI这两个概念是模糊不清的，是很难理解的，今天和大家分享网上的一些技术大牛们对Spring框架的IOC的理解以及谈谈我对Spring Ioc的理解。</p><h4 id="一、分享Iteye的开涛对Ioc的精彩讲解"><a href="#一、分享Iteye的开涛对Ioc的精彩讲解" class="headerlink" title="一、分享Iteye的开涛对Ioc的精彩讲解"></a>一、分享Iteye的开涛对Ioc的精彩讲解</h4><p>　　首先要分享的是Iteye的开涛这位技术牛人对Spring框架的IOC的理解，写得非常通俗易懂，以下内容全部来自原文，原文地址：<a href="http://jinnianshilongnian.iteye.com/blog/1413846">http://jinnianshilongnian.iteye.com/blog/1413846</a></p><h4 id="1-1、IoC是什么"><a href="#1-1、IoC是什么" class="headerlink" title="1.1、IoC是什么"></a>1.1、IoC是什么</h4><p>Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：</p><ul><li><p>谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</p></li><li><p>为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。</p></li></ul><p>　　用图例说明一下，传统程序设计如图2-1，都是主动去创建相关对象然后再组合起来：</p><p><img src="https://images0.cnblogs.com/blog/289233/201501/261421378318292.jpg" alt="如图2-1"></p><p>当有了IoC/DI的容器后，在客户端类中不再主动去创建这些对象了，如图2-2所示:</p><p><img src="data:image/png;base64,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" alt="如图"></p><h4 id="1-2、IoC能做什么"><a href="#1-2、IoC能做什么" class="headerlink" title="1.2、IoC能做什么"></a>1.2、IoC能做什么</h4><p>IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</p><p>　　其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。</p><p>　　IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</p><h4 id="1-3、IoC和DI"><a href="#1-3、IoC和DI" class="headerlink" title="1.3、IoC和DI"></a>1.3、IoC和DI</h4><p>　DI—Dependency Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p><p>　　理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：</p><p>　　●谁依赖于谁：当然是应用程序依赖于IoC容器；</p><p>　　●为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源；</p><p>　　●谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；</p><p>　　●注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。</p><p>　　IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。</p><p>　　看过很多对Spring的Ioc理解的文章，好多人对Ioc和DI的解释都晦涩难懂，反正就是一种说不清，道不明的感觉，读完之后依然是一头雾水，感觉就是开涛这位技术牛人写得特别通俗易懂，他清楚地解释了IoC(控制反转) 和DI(依赖注入)中的每一个字，读完之后给人一种豁然开朗的感觉。我相信对于初学Spring框架的人对Ioc的理解应该是有很大帮助的。</p><p>####二、分享Bromon的blog上对IoC与DI浅显易懂的讲解</p><p>2.1、IoC(控制反转)<br>　　首先想说说IoC（Inversion of Control，控制反转）。这是spring的核心，贯穿始终。所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。</p><p>　　那么IoC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。</p><p>2.2、DI(依赖注入)<br>　　IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。</p><p>　　理解了IoC和DI的概念后，一切都将变得简单明了，剩下的工作只是在spring的框架中堆积木而已。</p><h4 id="三、我对IoC-控制反转-和DI-依赖注入-的理解"><a href="#三、我对IoC-控制反转-和DI-依赖注入-的理解" class="headerlink" title="三、我对IoC(控制反转)和DI(依赖注入)的理解"></a>三、我对IoC(控制反转)和DI(依赖注入)的理解</h4><p>　　在平时的java应用开发中，我们要实现某一个功能或者说是完成某个业务逻辑时至少需要两个或以上的对象来协作完成，在没有使用Spring的时候，每个对象在需要使用他的合作对象时，自己均要使用像new object() 这样的语法来将合作对象创建出来，这个合作对象是由自己主动创建出来的，创建合作对象的主动权在自己手上，自己需要哪个合作对象，就主动去创建，创建合作对象的主动权和创建时机是由自己把控的，而这样就会使得对象间的耦合度高了，A对象需要使用合作对象B来共同完成一件事，A要使用B，那么A就对B产生了依赖，也就是A和B之间存在一种耦合关系，并且是紧密耦合在一起，而使用了Spring之后就不一样了，创建合作对象B的工作是由Spring来做的，Spring创建好B对象，然后存储到一个容器里面，当A对象需要使用B对象时，Spring就从存放对象的那个容器里面取出A要使用的那个B对象，然后交给A对象使用，至于Spring是如何创建那个对象，以及什么时候创建好对象的，A对象不需要关心这些细节问题(你是什么时候生的，怎么生出来的我可不关心，能帮我干活就行)，A得到Spring给我们的对象之后，两个人一起协作完成要完成的工作即可。</p><p>　　所以控制反转IoC(Inversion of Control)是说创建对象的控制权进行转移，以前创建对象的主动权和创建时机是由自己把控的，而现在这种权力转移到第三方，比如转移交给了IoC容器，它就是一个专门用来创建对象的工厂，你要什么对象，它就给你什么对象，有了 IoC容器，依赖关系就变了，原先的依赖关系就没了，它们都依赖IoC容器了，通过IoC容器来建立它们之间的关系。</p><p>　　这是我对Spring的IoC(控制反转)的理解。DI(依赖注入)其实就是IOC的另外一种说法，DI是由Martin Fowler 在2004年初的一篇论文中首次提出的。他总结：控制的什么被反转了？就是：获得依赖对象的方式反转了。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引</title>
      <link href="2020/12/10/Mysql%E7%B4%A2%E5%BC%95/"/>
      <url>2020/12/10/Mysql%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h3 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h3><p>数据库索引的原理：数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用 BTree 及其变种 B+Tree。</p><p>本文从如何建立 MySQL 索引以及介绍 MySQL 的索引类型，再讲 MySQL 索引的利与弊，以及建立索引时需要注意的地方。</p><p>首先:先假设有一张表,表的数据有 10W 条数据,其中有一条数据是 nickname=’css’ ,如果要拿这条数据的话需要些的 sql 是</p><pre><code> SELECT * FROM award WHERE nickname = &#39;css&#39;;</code></pre><p>一般情况下,在没有建立索引的时候, mysql 需要扫描全表及扫描 10W 条数据找这条数据,如果我在 nickname 上建立索引,那么mysql只需要扫描一行数据及为我们找到这条 nickname=’css’ 的数据,是不是感觉性能提升了好多咧….</p><p>mysql 的索引分为 单例索引（主键索引、唯一索引、普通索引）和 组合索引。</p><ul><li><p>单例索引：一个索引只包含一个列，一个表可以有多个单例索引。</p></li><li><p>组合索引：一个组合索引包含两个或两个以上的列。<br>本文使用的案例的表：</p><pre><code> CREATE TABLE `award` (   `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;用户id&#39;,   `aty_id` varchar(100) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;活动场景id&#39;,   `nickname` varchar(12) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;用户昵称&#39;,   `is_awarded` tinyint(1) NOT NULL DEFAULT 0 COMMENT &#39;用户是否领奖&#39;,   `award_time` int(11) NOT NULL DEFAULT 0 COMMENT &#39;领奖时间&#39;,   `account` varchar(12) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;帐号&#39;,   `password` char(32) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;密码&#39;,   `message` varchar(255) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;获奖信息&#39;,   `created_time` int(11) NOT NULL DEFAULT 0 COMMENT &#39;创建时间&#39;,   `updated_time` int(11) NOT NULL DEFAULT 0 COMMENT &#39;更新时间&#39;,   PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT=&#39;获奖信息表&#39;; INSERT INTO `award` (`nickname`, `account`, `message`, `created_time`)VALUES (&#39;rSUQFzpkDz3R&#39;, &#39;DYxJoqZq2rd7&#39;, &#39;aaabbbccccxuxuxuxuuxux&#39;, 1449567822);```</code></pre></li></ul><h4 id="一-索引的创建"><a href="#一-索引的创建" class="headerlink" title="(一) 索引的创建"></a>(一) 索引的创建</h4><ol><li>单例索引</li></ol><p>1.1）普通索引，这个是最基本的索引。</p><p>其 sql 格式是 :</p><pre><code> CREATE INDEX IndexName ON `TableName`(`字段名`(length));# 或者ALTER TABLE TableName ADD INDEX IndexName(`字段名`(length));</code></pre><p>第一种方式：</p><pre><code>CREATE INDEX account_Index ON `award`(`account`);</code></pre><p>第二种方式：</p><pre><code>ALTER TABLE award ADD INDEX account_Index(`account`);</code></pre><p>如果是 CHAR , VARCHAR 类型, length 可以小于字段的实际长度,如果是BLOB和TEXT类型就必须指定长度。</p><p>1.2）唯一索引，与普通索引类似，但是不同的是唯一索引要求所有的列的值是唯一的，这一点和主键索引一样，但是它允许有空值。</p><p>其 sql 格式是：</p><pre><code>CREATE UNIQUE INDEX IndexName ON `TableName`(`字段名`(length));# 或者ALTER TABLE TableName ADD UNIQUE (column_list); </code></pre><p>第一种方式</p><pre><code>CREATE UNIQUE INDEX account_UNIQUE_Index ON `award`(`account`);</code></pre><p>1.3）主键索引，不允许有空值,（在 B+Tree 中的 InnoDB 引擎中，主键索引起到了至关重要的位置）</p><p>主键索引建立的规则是 int 优于 varchar，一般在建表的时候创建，最好是与表的其他字段不相关的列或者是业务不相关的列。一般会设为 int 而且是 AUTO_INCREMENT 自增类型的。</p><ol start="2"><li>组合索引</li></ol><p>一个表中含有多个单例索引不代表是组合索引，通俗一点讲，组合索引是：包含多个字段但是只有索引名称。</p><p>其 sql 格式是：</p><pre><code>CREATE INDEX nickname_account_createdTime_Index ON `award`(`nickname`, `account`, `created_time`);</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/5114528-706c6315f0abee2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="avatar"></p><p>如果你建立了组合索引 (nickname_account_createdTime_Index)，那么它实际包含的是 3 个索引 (nickname) (nickname,account)(nickname,account,created_time)</p><p>在使用查询的时候遵循 mysql 组合索引的 “最左前缀”，即索引 where 时的条件要按照建立索引的时候字段的排列方式。</p><p>1、不按索引最左列开始查询（多列索引） 例如</p><pre><code> index(‘c1’, ‘c2’, ‘c3’) where c2 = &#39;aaa&#39; # 不使用索引 where c2 = &#39;aaa&#39; and c3=&#39;sss&#39; # 不能使用索引</code></pre><p>2、查询某个列有范围查询，则其右边的所有列都无法使用查询（多列查询）</p><pre><code>Where c1= &#39;xxx&#39; and c2 like &#39;aa%&#39; and c3=&#39;sss&#39;# 该查询只会使用索引中的前两列,因为like是范围查询</code></pre><p>3、不能跳过某个字段来进行查询，这样利用不到索引，比如：</p><pre><code>EXPLAIN SELECT * FROM `award` WHERE nickname &gt; &#39;rSUQFzpkDz3R&#39; AND account = &#39;DYxJoqZq2rd7&#39; AND created_time = 1449567822; </code></pre><p>因为我的索引是 (nickname, account, created_time)，如果第一个字段出现 范围符号 的查找，那么将不会用到索引，如果我是第二个或者第三个字段使用范围符号的查找，那么它会利用索引，利用的索引是 (nickname)，因为上面说了建立组合索引 (nickname, account, created_time)，会出现三个索引。</p><p><img src="https://upload-images.jianshu.io/upload_images/5114528-e89fefe045067907.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="avatar"></p><p>注：使用组合检索的时候可能需要把前面创建的单例检索删除，否则可能会使用单例检索</p><p>3.全文索引</p><p>文本字段上（text）如果建立的是普通索引，那么只有对文本的字段内容前面的字符进行索引，其字符大小根据索引建立索引时声明的大小来规定。</p><p>如果文本中出现多个一样的字符，而且需要查找的话，那么其条件只能是 where column like ‘%xxxx%’， 这样做会让索引失效</p><p>这个时候全文索引就有作用了</p><pre><code>ALTER TABLE TableName ADD FULLTEXT(column1, column2);ALTER TABLE `award` ADD FULLTEXT(`message`);</code></pre><p>ALTER TABLE <code>award</code> ADD FULLTEXT(<code>message</code>);<br>有了全文索引，就可以用 SELECT 查询命令去检索那些包含着一个或多个给定单词的数据记录了。</p><pre><code>SELECT * FROM TableName WHERE MATCH(column1, column2) AGAINST(&#39;xxx&#39;, &#39;sss&#39;, &#39;ddd&#39;);SELECT * FROM TableName WHERE MATCH(column1, column2) AGAINST(&#39;xxx&#39;, &#39;sss&#39;, &#39;ddd&#39;);</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/5114528-1940bc1006952c47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="avatar"></p><h3 id="使用索引的优点"><a href="#使用索引的优点" class="headerlink" title="使用索引的优点"></a>使用索引的优点</h3><p>1）可以通过建立唯一索引或者主键索引，保证数据库表中每一行数据的唯一性</p><p>2）建立索引可以大大提高检索的数据，以及减少表的检索行数</p><p>3）在表连接的连接条件，可以加速表与表直接的相连</p><p>4）在分组和排序字句进行数据检索，可以减少查询时间中 分组 和 排序 所消耗的时间（数据库的记录会重新排序）</p><p>5）建立索引，在查询中使用索引，可以提高性能</p><h3 id="使用索引的缺点"><a href="#使用索引的缺点" class="headerlink" title="使用索引的缺点"></a>使用索引的缺点</h3><p>1）创建索引和维护索引会消耗时间，随着数据量的增加而增加</p><p>2）索引文件会占用物理空间，除了数据表需要占用物理空间之外，每一个索引还会占用一定的物理空间</p><p>3）当对表的数据进行 INSERT,UPDATE,DELETE 的时候,索引也要动态的维护,这样就会降低数据的维护速度,(建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快)。</p><h3 id="五-使用索引需要注意的地方"><a href="#五-使用索引需要注意的地方" class="headerlink" title="(五) 使用索引需要注意的地方"></a>(五) 使用索引需要注意的地方</h3><p>在建立索引的时候应该考虑索引该建立在数据库表中的某些列上，哪一些索引需要建立，哪一些索引是多余的，一般来说：</p><p>1）在经常需要搜索的列上,可以加快索引的速度</p><p>2）主键列上可以确保列的唯一性</p><p>3）在表与表的连接条件上加上索引,可以加快连接查询的速度</p><p>4）在经常需要排序 (order by) ,分组 (group by) 和的 distinct 列上加索引 可以加快排序查询的时间, (单独order by 用不了索引，索引考虑加where 或加limit)</p><p>5）在一些 where 之后的 &lt; &lt;= &gt; &gt;= BETWEEN IN 以及某个情况下的like 建立字段的索引(B-TREE)</p><p>6）like语句，前导模糊查询 like “%XXX” 不能使用索引，而非前导模糊查询 like “XXX%” 则可以</p><p>7）索引不会包含 NULL 列,如果列中包含 NULL 值都将不会被包含在索引中,复合索引中如果有一列含有NULL值那么这个组合索引都将失效,一般需要给默认值0或者 ‘ ‘ 字符串</p><p>8）使用短索引,如果你的一个字段是 Char(32) 或者 int(32) ,在创建索引的时候指定前缀长度 比如前10个字符 (前提是多数值是唯一的..)那么短索引可以提高查询速度,并且可以减少磁盘的空间,也可以减少I/0操作.</p><p>9）不要在列上进行运算,这样会使得mysql索引失效,也会进行全表扫描</p><p>10）选择越小的数据类型越好,因为通常越小的数据类型通常在磁盘,内存,cpu,缓存中 占用的空间很少,处理起来更快</p><h3 id="六-什么情况下不创建索引"><a href="#六-什么情况下不创建索引" class="headerlink" title="(六) 什么情况下不创建索引"></a>(六) 什么情况下不创建索引</h3><p>1）查询中很少使用到的列不应该创建索引,如果建立了索引然而还会降低mysql的性能和增大了空间需求.</p><p>2）很少数据的列也不应该建立索引,比如 一个性别字段 0或者1,在查询中,结果集的数据占了表中数据行的比例比较大,mysql需要扫描的行数很多,增加索引,并不能提高效率</p><p>3）定义为 text 和 image 和 bit 数据类型的列不应该增加索引</p><p>4）当表的修改(UPDATE,INSERT,DELETE)操作远远大于检索(SELECT)操作时不应该创建索引,这两个操作是互斥的关系</p><h3 id="七-MySQL-优化之道"><a href="#七-MySQL-优化之道" class="headerlink" title="(七) MySQL 优化之道"></a>(七) MySQL 优化之道</h3><p>一些常见的 SQL 实践</p><ul><li><p>负向条件不能使用索引</p><p>  select from order where status!=0 and status!=1</p><p>  not in/not exists # 都不是好习惯</p></li></ul><p>可以优化为 in 查询：<br>    select from order where status in(2,3)</p><ul><li><p>前导模糊查询不能使用索引</p><p>  select from order where desc like ‘%XX’</p></li></ul><p>而非前导模糊查询则可以：</p><pre><code>select from order where desc like &#39;XX%&#39;</code></pre><ul><li><p>数据区分度不大的字段不宜使用索引</p><p>  select from user where sex=1</p></li></ul><p>原因：性别只有男，女，每次过滤掉的数据很少，不宜使用索引。</p><p>经验上，能过滤80%数据时就可以使用索引。对于订单状态，如果状态值很少，不宜使用索引，如果状态值很多，能够过滤大量数据，则应该建立索引。</p><ul><li><p>在属性上进行计算不能命中索引</p><p>  select from order_ where YEAR(date) &lt;= ‘2017’</p></li></ul><p>即使 date 上建立了索引，也会全表扫描，可优化为值计算：</p><pre><code>select from order_ where date &lt;= CURDATE()</code></pre><p>或者：</p><pre><code>select from order_ where date &lt; = &#39;2017-01-01&#39;</code></pre><p>并非周知的 SQL 实践</p><ul><li><p>如果业务大部分是单条查询，使用 Hash 索引性能更好，例如用户中心</p><p>  select from <code>user</code> where uid = ?<br>  select from user where login_name=?</p></li></ul><p>原因：B-Tree索引的时间复杂度是 O(log(n))；Hash 索引的时间复杂度是 O(1)</p><ul><li>允许 null的列，查询有潜在大坑</li></ul><p>单列索引不存 null 值，复合索引不存全为 null 的值，如果列允许为 null，可能会得到“不符合预期”的结果集</p><pre><code>select from user where name != &#39;shenjian&#39;</code></pre><p>如果 name 允许为 null，索引不存储null值，结果集中不会包含这些记录。所以，请使用 not null 约束以及默认值。</p><ul><li>复合索引最左前缀，并不是指 SQL 语句的 where顺序要和符合索引一致。</li></ul><p>用户中心建立了 (login_name, password) 的符合索引</p><pre><code>select from user where login_name=? and passwd=?select from user where passwd=? and login_name=?</code></pre><p>都能够命中索引</p><pre><code>select from user where login_name=?</code></pre><p>也能命中索引，满足符合索引最左前缀</p><pre><code>select from user where passwd=?</code></pre><p>不能命中索引，不满足符合索引最左前缀。</p><ul><li>使用 ENUM 而不是字符串</li></ul><p>ENUM 保存的是 TINYINT，别在枚举中搞一些“中国”“北京”“技术部”这样的字符串，字符串空间又大，效率又低。</p><p><strong>小众但有用的 SQL 实践</strong></p><ul><li><p>如果明确知道只有一条结果返回，limit 1 能够提高效率</p><p>  select from user where login_name=?</p></li></ul><p>可以优化为：</p><p>select from user where login_name=? limit 1</p><p>原因：你知道只有一条结果，但数据库并不知道，明确告诉它，让它主动停止游标移动</p><ul><li>把计算放到业务层而不是数据库层，除了节省数据的 CPU，还有意想不到的查询缓存优化效果</li></ul><pre><code>select from order where date &lt; = CURDATE()</code></pre><p>这不是一个号的 SQL 实践，应该优化为：</p><pre><code>$curDate = date(&#39;Y-m-d&#39;);$res = mysqlquery(&#39;select from order where date &lt; = $curDate&#39;);</code></pre><p>原因：释放了数据库的 CPU，多次调用，传入的SQL相同，才可以利用查询缓存</p><ul><li>强制类型转换会全表扫描  select from user where phone=13800001234</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo入门</title>
      <link href="2020/11/12/Dubbo%E5%85%A5%E9%97%A8/"/>
      <url>2020/11/12/Dubbo%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>###一 重要的概念<br>####1.1 什么是 Dubbo?<br>Apache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC 框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。简单来说 Dubbo 是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。</p><p>Dubbo 目前已经有接近 23k 的 Star ，Dubbo的Github 地址：<a href="https://github.com/apache/incubator-dubbo">https://github.com/apache/incubator-dubbo</a> 。 另外，在开源中国举行的2018年度最受欢迎中国开源软件这个活动的评选中，Dubbo 更是凭借其超高人气仅次于 vue.js 和 ECharts 获得第三名的好成绩。</p><p>Dubbo 是由阿里开源，后来加入了 Apache 。正式由于 Dubbo 的出现，才使得越来越多的公司开始使用以及接受分布式架构。</p><p><strong>我们上面说了 Dubbo 实际上是 RPC 框架，那么什么是 RPC呢？</strong></p><h4 id="1-2-什么是-RPC-RPC原理是什么"><a href="#1-2-什么是-RPC-RPC原理是什么" class="headerlink" title="1.2 什么是 RPC?RPC原理是什么?"></a>1.2 什么是 RPC?RPC原理是什么?</h4><p><strong>什么是 RPC？</strong></p><p>RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 HTTP请求当然可以，但是可能会比较麻烦。 RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单。</p><p><strong>RPC原理是什么？</strong></p><p>我这里这是简单的提一下。详细内容可以查看下面这篇文章：<br><a href="http://www.importnew.com/22003.html">http://www.importnew.com/22003.html</a></p><p><img src="https://img-blog.csdnimg.cn/img_convert/3e77032251e377a75918a7d099a8cba6.png" alt="avatar"></p><ol><li>服务消费方（client）调用以本地调用方式调用服务；</li><li>client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</li><li>client stub找到服务地址，并将消息发送到服务端；</li><li>server stub收到消息后进行解码；</li><li>server stub根据解码结果调用本地的服务；</li><li>本地服务执行并将结果返回给server stub；</li><li>server stub将返回结果打包成消息并发送至消费方；</li><li>client stub接收到消息，并进行解码；</li><li>服务消费方得到最终结果。</li></ol><p>下面再贴一个网上的时序图：<br><img src="https://img-blog.csdnimg.cn/img_convert/ba1c80f88f2c46cfaa7f69368c890a68.png" alt="avatar"></p><p><strong>说了这么多，我们为什么要用 Dubbo 呢？</strong></p><h4 id="1-3-为什么要用-Dubbo"><a href="#1-3-为什么要用-Dubbo" class="headerlink" title="1.3 为什么要用 Dubbo?"></a>1.3 为什么要用 Dubbo?</h4><p>Dubbo 的诞生和 SOA 分布式架构的流行有着莫大的关系。SOA 面向服务的架构（Service Oriented Architecture），也就是把工程按照业务逻辑拆分成服务层、表现层两个工程。服务层中包含业务逻辑，只需要对外提供服务即可。表现层只需要处理和页面的交互，业务逻辑都是调用服务层的服务来实现。SOA架构中有两个主要角色：服务提供者（Provider）和服务使用者（Consumer）。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/8a3cd482f38e8329ae71b344feeb2d29.png" alt="avatar"></p><p><strong>如果你要开发分布式程序，你也可以直接基于 HTTP 接口进行通信，但是为什么要用 Dubbo呢？</strong></p><p>我觉得主要可以从 Dubbo 提供的下面四点特性来说为什么要用 Dubbo：</p><ol><li>负载均衡——同一个服务部署在不同的机器时该调用那一台机器上的服务。</li><li>服务调用链路生成——随着系统的发展，服务越来越多，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。Dubbo 可以为我们解决服务之间互相是如何调用的。</li><li>服务访问压力以及时长统计、资源调度和治理——基于访问压力实时管理集群容量，提高集群利用率。</li><li>服务降级——某个服务挂掉之后调用备用服务。</li></ol><p>另外，Dubbo 除了能够应用在分布式系统中，也可以应用在现在比较火的微服务系统中。不过，由于 Spring Cloud 在微服务中应用更加广泛，所以，我觉得一般我们提 Dubbo 的话，大部分是分布式系统的情况。</p><p><strong>我们刚刚提到了分布式这个概念，下面再给大家介绍一下什么是分布式？为什么要分布式？</strong></p><h4 id="1-4-什么是分布式"><a href="#1-4-什么是分布式" class="headerlink" title="1.4 什么是分布式?"></a>1.4 什么是分布式?</h4><p>分布式或者说 SOA 分布式重要的就是面向服务，说简单的分布式就是我们把整个系统拆分成不同的服务然后将这些服务放在不同的服务器上减轻单体服务的压力提高并发量和性能。比如电商系统可以简单地拆分成订单系统、商品系统、登录系统等等，拆分之后的每个服务可以部署在不同的机器上，如果某一个服务的访问量比较大的话也可以将这个服务同时部署在多台机器上。</p><h4 id="1-5-为什么要分布式"><a href="#1-5-为什么要分布式" class="headerlink" title="1.5 为什么要分布式?"></a>1.5 为什么要分布式?</h4><p>从开发角度来讲单体应用的代码都集中在一起，而分布式系统的代码根据业务被拆分。所以，每个团队可以负责一个服务的开发，这样提升了开发效率。另外，代码根据业务拆分之后更加便于维护和扩展。</p><p>另外，我觉得将系统拆分成分布式之后不光便于系统扩展和维护，更能提高整个系统的性能。你想一想嘛？把整个系统拆分成不同的服务/系统，然后每个服务/系统 单独部署在一台服务器上，是不是很大程度上提高了系统性能呢？</p><p>###二 Dubbo 的架构<br>2.1 Dubbo 的架构图解</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7ea57c27be635128648f43c6a46ffd10.png" alt="avatar"></p><p><strong>上述节点简单说明：</strong></p><ul><li>Provider： 暴露服务的服务提供方</li><li>Consumer： 调用远程服务的服务消费方</li><li>Registry： 服务注册与发现的注册中心</li><li>Monitor： 统计服务的调用次数和调用时间的监控中心</li><li>Container： 服务运行容器</li></ul><p>调用关系说明：</p><ol><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol><p><strong>重要知识点总结：</strong></p><ul><li>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小</li><li>监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示</li><li>注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外</li><li>注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者</li><li>注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表</li><li>注册中心和监控中心都是可选的，服务消费者可以直连服务提供者</li><li>服务提供者无状态，任意一台宕掉后，不影响使用</li><li>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</li></ul><h4 id="2-2-Dubbo-工作原理"><a href="#2-2-Dubbo-工作原理" class="headerlink" title="2.2 Dubbo 工作原理"></a>2.2 Dubbo 工作原理</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/dca61bbc55e64f1f4f509197d0b577fa.png" alt="avatar"></p><p>图中从下至上分为十层，各层均为单向依赖，右边的黑色箭头代表层之间的依赖关系，每一层都可以剥离上层被复用，其中，Service 和 Config 层为 API，其它各层均为 SPI。</p><p><strong>各层说明：</strong></p><ul><li>第一层：service层，接口层，给服务提供者和消费者来实现的</li><li>第二层：config层，配置层，主要是对dubbo进行各种配置的</li><li>第三层：proxy层，服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton</li><li>第四层：registry层，服务注册层，负责服务的注册与发现</li><li>第五层：cluster层，集群层，封装多个服务提供者的路由以及负载均衡，将多个实例组合成一个服务</li><li>第六层：monitor层，监控层，对rpc接口的调用次数和调用时间进行监控</li><li>第七层：protocol层，远程调用层，封装rpc调用</li><li>第八层：exchange层，信息交换层，封装请求响应模式，同步转异步</li><li>第九层：transport层，网络传输层，抽象mina和netty为统一接口</li><li>第十层：serialize层，数据序列化层，网络传输需要</li></ul><p>###三 Dubbo 的负载均衡策略<br>####3.1 先来解释一下什么是负载均衡<br><strong>先来个官方的解释。</strong></p><p>维基百科对负载均衡的定义：负载均衡改善了跨多个计算资源（例如计算机，计算机集群，网络链接，中央处理单元或磁盘驱动的的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间，并避免任何单个资源的过载。使用具有负载平衡而不是单个组件的多个组件可以通过冗余提高可靠性和可用性。负载平衡通常涉及专用软件或硬件。</p><p><strong>上面讲的大家可能不太好理解，再用通俗的话给大家说一下。</strong></p><p>比如我们的系统中的某个服务的访问量特别大，我们将这个服务部署在了多台服务器上，当客户端发起请求的时候，多台服务器都可以处理这个请求。那么，如何正确选择处理该请求的服务器就很关键。假如，你就要一台服务器来处理该服务的请求，那该服务部署在多台服务器的意义就不复存在了。负载均衡就是为了避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题，我们从负载均衡的这四个字就能明显感受到它的意义。</p><p>####3.2 再来看看 Dubbo 提供的负载均衡策略<br>在集群负载均衡时，Dubbo 提供了多种均衡策略，默认为 random 随机调用。可以自行扩展负载均衡策略，参见：负载均衡扩展。</p><p>备注:下面的图片来自于：尚硅谷2018Dubbo 视频。</p><p>#####3.2.1 Random LoadBalance(默认，基于权重的随机负载均衡机制)</p><ul><li>随机，按权重设置随机概率。</li><li>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/bc5644e81dbd796308b9211e840db6c4.png" alt="avatar"></p><h5 id="3-2-2-RoundRobin-LoadBalance-不推荐，基于权重的轮询负载均衡机制"><a href="#3-2-2-RoundRobin-LoadBalance-不推荐，基于权重的轮询负载均衡机制" class="headerlink" title="3.2.2 RoundRobin LoadBalance(不推荐，基于权重的轮询负载均衡机制)"></a>3.2.2 RoundRobin LoadBalance(不推荐，基于权重的轮询负载均衡机制)</h5><ul><li>轮循，按公约后的权重设置轮循比率。</li><li>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/9164315370b4b8ae99003a47a522bccf.png" alt="avatar"></p><h5 id="3-2-3-LeastActive-LoadBalance"><a href="#3-2-3-LeastActive-LoadBalance" class="headerlink" title="3.2.3 LeastActive LoadBalance"></a>3.2.3 LeastActive LoadBalance</h5><ul><li>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</li><li>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</li></ul><h5 id="3-2-4-ConsistentHash-LoadBalance"><a href="#3-2-4-ConsistentHash-LoadBalance" class="headerlink" title="3.2.4 ConsistentHash LoadBalance"></a>3.2.4 ConsistentHash LoadBalance</h5><ul><li>一致性 Hash，相同参数的请求总是发到同一提供者。(如果你需要的不是随机负载均衡，是要一类请求都到一个节点，那就走这个一致性hash策略。)</li><li>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</li><li>算法参见：<a href="http://en.wikipedia.org/wiki/Consistent_hashing">http://en.wikipedia.org/wiki/Consistent_hashing</a></li><li>缺省只对第一个参数 Hash，如果要修改，请配置 <code>&lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</code></li><li>缺省用 160 份虚拟节点，如果要修改，请配置 `&lt;dubbo:parameter key=”hash.nodes” value=”320” /&gt;</li></ul><h5 id="3-3-配置方式"><a href="#3-3-配置方式" class="headerlink" title="3.3 配置方式"></a>3.3 配置方式</h5><p><strong>xml 配置方式</strong></p><p>服务端服务级别</p><pre><code>&lt;dubbo:service interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&gt;</code></pre><p>客户端服务级别</p><pre><code>&lt;dubbo:reference interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&gt;</code></pre><p>服务端方法级别</p><pre><code>   &lt;dubbo:service interface=&quot;...&quot;&gt;     &lt;dubbo:method name=&quot;...&quot; loadbalance=&quot;roundrobin&quot;/&gt;&lt;/dubbo:service&gt;</code></pre><p>客户端方法级别</p><pre><code>&lt;dubbo:reference interface=&quot;...&quot;&gt;   &lt;dubbo:method name=&quot;...&quot; loadbalance=&quot;roundrobin&quot;/&gt;&lt;/dubbo:reference&gt;</code></pre><p><strong>注解配置方式：</strong></p><p>消费方基于基于注解的服务级别配置方式：</p><pre><code>@Reference(loadbalance = &quot;roundrobin&quot;)HelloService helloService;</code></pre><h3 id="四-zookeeper宕机与dubbo直连的情况"><a href="#四-zookeeper宕机与dubbo直连的情况" class="headerlink" title="四 zookeeper宕机与dubbo直连的情况"></a>四 zookeeper宕机与dubbo直连的情况</h3><p>zookeeper宕机与dubbo直连的情况在面试中可能会被经常问到，所以要引起重视。</p><p>在实际生产中，假如zookeeper注册中心宕掉，一段时间内服务消费方还是能够调用提供方的服务的，实际上它使用的本地缓存进行通讯，这只是dubbo健壮性的一种体现。</p><p><strong>dubbo的健壮性表现：</strong></p><ol><li>监控中心宕掉不影响使用，只是丢失部分采样数据</li><li>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务</li><li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台</li><li>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</li><li>服务提供者无状态，任意一台宕掉后，不影响使用</li><li>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</li></ol><p>我们前面提到过：注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。所以，我们可以完全可以绕过注册中心——采用 dubbo 直连 ，即在服务消费方配置服务提供方的位置信息。</p><p><strong>xml配置方式：</strong></p><pre><code>&lt;dubbo:reference id=&quot;userService&quot; interface=&quot;com.zang.gmall.service.UserService&quot; url=&quot;dubbo://localhost:20880&quot; /&gt;</code></pre><p><strong>注解方式：</strong></p><pre><code> @Reference(url = &quot;127.0.0.1:20880&quot;)    HelloService helloService;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis知识点整理</title>
      <link href="2020/10/05/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
      <url>2020/10/05/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>###1. Redis 数据结构<br>####1.主要的数据类型:</p><ul><li><p>String(K-V): 单值，键值对，类似 Memcached， 比如配置，常量值，开关等等。</p></li><li><p>Hash: 一般是存储对象接口，key 是对象的标示，filed 是属性，value 是属性值。</p></li><li><p>Set: 集合，存放不重复的数据，求交集，统计不重复的量。</p></li><li><p>List: 链表，常用在消息队列，TimeLine.</p></li><li><p>SortedSet: 排名，需要根据 一个值来排序的场景，排行榜等。<br>####2.扩展数据类型</p></li><li><p>Pub/Sub 简单的发布/订阅，当订阅的 key 的值有变化的时候，会通知到订阅的客户端，回调。</p></li><li><p>HyperLogLog: 基数统计（B 树，bitmap，概率算法（LC,LLC，HLL）），统计一个大的集合（可能出现重复数据）中不同元素的个数。</p></li><li><p>比如网站的 UV，链接访问的 UV，以及做合并的功能，还有留存。</p></li><li><p>Geo 地址位置信息</p><h4 id="3-Redis-Module-Redis-拓展模块"><a href="#3-Redis-Module-Redis-拓展模块" class="headerlink" title="3.Redis Module : Redis 拓展模块"></a>3.Redis Module : Redis 拓展模块</h4></li></ul><p>#####BloomFilter: 布隆过滤器，快速判断一个元素是否在集合中。</p><ul><li>就是一个很长的二进制 bit 位的数组，全部初始化为 0.</li><li>K 个 hash 函数，每个 hash 函数会生成一个 hash 值。这个 hash 值对应了二进制 数组的某个点,然后将这个点标记为 1.</li><li>查询一个数据存在不存在时，需要判断 这 K 个点的位置是否都未为 1.</li><li>布隆过滤器添加元素<br>1.将要添加的元素给k个哈希函数<br>2.得到对应于位数组上的k个位置<br>3.将这k个位置设为1<br>布隆过滤器查询元素<br>将要查询的元素给k个哈希函数<br>得到对应于位数组上的k个位置<br>如果k个位置有一个为0，则肯定不在集合中<br>如果k个位置全部为1，则可能在集合中<br>优点: 是占用空间小，效率高。<br>缺点: 有误判，不允许删除。如果需要删除，可以CBF,每一位是一个 counter，不再是0和1两种结果。<br>RedisSearch</li></ul><p>Redis-ML，</p><ol start="2"><li>Redis 分布式锁<br>setnx抢锁，然后设置一个 过期时间。不能先 set 抢锁，再 expire，必须保证原子性。<br>spring-data-redis:2.1版本后，使用 setIfAbsent(K key, V value, long timeout, TimeUnit unit) 方法来实现。</li><li>Redis 查找指定格式的 key<br>如果使用 keys ，但是会卡住 redis，因为 redis 是单线程的。所以可以用 scan，但是会有重复，需要客户端做一次去重复。</li><li>Redis 做异步队列<br>一般用 list 作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，适当的 sleep 一定的时间再重试，如果不用 sleep。可以用 blpop 命令，如果没有消息，会一直阻塞到消息来为止。<br>通过 pub/sub 订阅者模式 来做一次生产，多次消费，可以实现 1:N 的消息队列。pub/sub 的缺点是，在消费者下线过后，生产的消息会丢失，如果需要保证不丢失，需要使用 MQ.<br>redis 实现延时队列，用时间戳做 score，消息内容做 member, 然后通过 ZADD 添加消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询处理。不过不建议，太占用内容。队列还是建议使用 MQ, Kafka</li><li>key 的过期时间<br>如果有大量的 key 在同一个时间过期，防止 redis 暂时的卡顿，在时间上面加一个随机值，使得过期时间分散一些。</li><li>Redis 持久化<br><a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html">http://oldblog.antirez.com/post/redis-persistence-demystified.html</a><br>持久化方式：<br>RDB 指定间隔时间的某个时间点的快照。<br>AOF 持久化操作日志。当 redis 重启的时候，需要根据 AOF 的 log 文件来重构数据。AOF 日志文件是redis 的自定义格式。当 AOF文件太大，redis 会重写该日志文件，减少命令数，但是结果一致。比如多次累加一个 key 100次。aof 就会有100条语句，BGREWRITEAOF会精简命令。<br>可以禁用 redis 的持久化，只要我们想让我们的数据只在 redis 运行时存在。<br>可以同时使用 AOF 和 RDB 来持久化 redis 中的数据。需要注意的是，此时，Redis 重启时，AOF 的日志文件会被用来重构 redis 中的数据，以此来保证数据的完整性。<br>RDB 做全量持久化，AOF 做增量持久化。RDB 每次消耗的时间长，down 机时，会丢失两次持久化之间的数据。所以，需要配合 AOF 来使用。Redis 重启时，先用 RDB 持久化的文件重构内存，然后使用 AOF 回放最近的操作指令来实现完整恢复重启之前的状态。<br>对于突然断电的结果，取决于 AOF 刷新日志到磁盘的时间间隔 sync。建议是 1s 刷新一次。<br>RDB 的原理，就是 fork &amp; COW. fork 过后，子进程和父进程共享数据段，此时，可以看做没有占用额外的内存开销。当父进程的数据有修改时，才会复制一份到子进程保存。所以，只有在极限情况，所有的父进程数据有修改，及其的物理内存使用率才会是 50%。<br>RDB 的优点是重启快，缺点是会丢失数据，备份一次的时间长。AOF 的优点是可以做到不丢失数据或者丢失很少的数据，但是重启很慢，因为需要重新根据日志来构建 redis 数据。所以往往是 RDB 和 AOF 搭配使用。</li><li>Pipline<br>Pipline 的好处是可以将多次 IO 减少为 1次。前提是这些之类之间没有因果相关性</li><li>Redis 的同步机制<br>Redis 可以使用主从同步，从从同步。<br>启动时，做第一次同步，主节点做一次 rdb，同时将后续修改操作放入 buffer,待 rdb 完成后。将 rdb 文件全量同步到 从节点，从节点接受完成后讲 rdb 镜像加载到内存。加载完成后，再通知主节点讲期间修改的 缓存 buffer 发送过来。<br>以上是第一次启动时候的同步，当机器都启动完成后，后面通过 AOF 做同步就是近乎实时。</li><li>Redis 集群<br>Redis-sentinal 是着眼于高可用性。在 master down 机时，能在 slave 中选举一个新的 master，继续提供服务。<br>Redis-cluster 着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</li></ol><p>redis 集群的 键分布模型，</p><p>采用的 一种 hash slot(hash槽) 的 sharding 方式，而不是一致性 hash<br>Redis 集群的键空间被分割为 16384 个槽（slot）， 集群的最大节点数量也是 16384 个,推荐的最大节点数量为 1000 个左右。<br>每个主节点都负责处理 16384 个槽中的一部分。<br>使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽<br>删除某个节点：只需要将删除的节点中的槽移动到其它的节点，然后再移除空白槽需要删除的节点。<br>增加一个节点：只需要将当前所有节点中的某些槽移动到新的节点。<br>因为将一个 hash 槽从一个节点移动到另一个节点，不会造成节点堵塞，所以无论是添加还是移除已经存在的节点，又或者改变某个节点包含的 hash 槽数，不会造成集群下线。</p><p>Redis 集群不保证数据的强一致性（strong consistency）： 在特定条件下， Redis 集群可能会丢失已经被执行过的写命令。</p><ol start="10"><li>Redis 集群搭建</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql高性能优化规范建议</title>
      <link href="2020/10/02/Mysql%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%AE/"/>
      <url>2020/10/02/Mysql%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="数据库命令规范"><a href="#数据库命令规范" class="headerlink" title="数据库命令规范"></a>数据库命令规范</h3><ul><li>所有数据库对象名称必须使用小写字母并用下划线分割</li><li>所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）</li><li>数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符</li><li>临时库表必须以 tmp_为前缀并以日期为后缀，备份表必须以 bak_为前缀并以日期 (时间戳) 为后缀</li><li>所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）</li></ul><h3 id="数据库基本设计规范"><a href="#数据库基本设计规范" class="headerlink" title="数据库基本设计规范"></a>数据库基本设计规范</h3><h4 id="1-所有表必须使用-Innodb-存储引擎"><a href="#1-所有表必须使用-Innodb-存储引擎" class="headerlink" title="1. 所有表必须使用 Innodb 存储引擎"></a>1. 所有表必须使用 Innodb 存储引擎</h4><p>没有特殊要求（即 Innodb 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 Innodb 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 Innodb）。</p><p>Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。</p><h5 id="2-数据库和表的字符集统一使用-UTF8"><a href="#2-数据库和表的字符集统一使用-UTF8" class="headerlink" title="2. 数据库和表的字符集统一使用 UTF8"></a>2. 数据库和表的字符集统一使用 UTF8</h5><p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。</p><h4 id="3-所有表和字段都需要添加注释"><a href="#3-所有表和字段都需要添加注释" class="headerlink" title="3. 所有表和字段都需要添加注释"></a>3. 所有表和字段都需要添加注释</h4><p>使用 comment 从句添加表和列的备注，从一开始就进行数据字典的维护</p><h4 id="4-尽量控制单表数据量的大小-建议控制在-500-万以内。"><a href="#4-尽量控制单表数据量的大小-建议控制在-500-万以内。" class="headerlink" title="4. 尽量控制单表数据量的大小,建议控制在 500 万以内。"></a>4. 尽量控制单表数据量的大小,建议控制在 500 万以内。</h4><p>500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。</p><p>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p><h4 id="5-谨慎使用-MySQL-分区表"><a href="#5-谨慎使用-MySQL-分区表" class="headerlink" title="5. 谨慎使用 MySQL 分区表"></a>5. 谨慎使用 MySQL 分区表</h4><p>分区表在物理上表现为多个文件，在逻辑上表现为一个表；</p><p>谨慎选择分区键，跨分区查询效率可能更低；</p><p>建议采用物理分表的方式管理大数据。</p><h4 id="6-尽量做到冷热数据分离-减小表的宽度"><a href="#6-尽量做到冷热数据分离-减小表的宽度" class="headerlink" title="6.尽量做到冷热数据分离,减小表的宽度"></a>6.尽量做到冷热数据分离,减小表的宽度</h4><p>MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节。</p><p>减少磁盘 IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的 IO）；</p><p>更有效的利用缓存，避免读入无用的冷数据；</p><p>经常一起使用的列放到一个表中（避免更多的关联操作）。</p><h4 id="7-禁止在表中建立预留字段"><a href="#7-禁止在表中建立预留字段" class="headerlink" title="7. 禁止在表中建立预留字段"></a>7. 禁止在表中建立预留字段</h4><p>预留字段的命名很难做到见名识义。</p><p>预留字段无法确认存储的数据类型，所以无法选择合适的类型。</p><p>对预留字段类型的修改，会对表进行锁定。</p><h4 id="8-禁止在数据库中存储图片-文件等大的二进制数据"><a href="#8-禁止在数据库中存储图片-文件等大的二进制数据" class="headerlink" title="8. 禁止在数据库中存储图片,文件等大的二进制数据"></a>8. 禁止在数据库中存储图片,文件等大的二进制数据</h4><p>通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机 IO 操作，文件很大时，IO 操作很耗时。</p><p>通常存储于文件服务器，数据库只存储文件地址信息</p><p>####9. 禁止在线上做数据库压力测试<br>####10. 禁止从开发环境,测试环境直接连接生成环境数据库<br>###数据库字段设计规范<br><strong>1. 优先选择符合存储需要的最小的数据类型<br>原因：</strong></p><p>列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的 IO 次数也就越多，索引的性能也就越差。</p><p>方法：</p><p>a.将字符串转换成数字类型存储,如:将 IP 地址转换成整形数据</p><p>MySQL 提供了两个方法来处理 ip 地址</p><p>•inet_aton 把 ip 转为无符号整型 (4-8 位)</p><p>•inet_ntoa 把整型的 ip 转为地址</p><p>插入数据前，先用 inet_aton 把 ip 地址转为整型，可以节省空间，显示数据时，使用 inet_ntoa 把整型的 ip 地址转为地址显示即可。</p><p>b.对于非负型的数据 (如自增 ID,整型 IP) 来说,要优先使用无符号整型来存储</p><p>原因：</p><p>无符号相对于有符号可以多出一倍的存储空间</p><p>SIGNED INT -2147483648<del>2147483647<br>UNSIGNED INT 0</del>4294967295<br>VARCHAR(N) 中的 N 代表的是字符数，而不是字节数，使用 UTF8 存储 255 个汉字 Varchar(255)=765 个字节。过大的长度会消耗更多的内存。</p><p>###2. 避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据<br><strong>a. 建议把 BLOB 或是 TEXT 列分离到单独的扩展表中</strong></p><p>MySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。而且对于这种数据，MySQL 还是要进行二次查询，会使 sql 性能变得很差，但是不是说一定不能使用这样的数据类型。</p><p>如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 select * 而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。</p><p><strong>2、TEXT 或 BLOB 类型只能使用前缀索引</strong></p><p>因为MySQL[1] 对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的</p><p><strong>3. 避免使用 ENUM 类型</strong></p><p>修改 ENUM 值需要使用 ALTER 语句</p><p>ENUM 类型的 ORDER BY 操作效率低，需要额外操作</p><p>禁止使用数值作为 ENUM 的枚举值</p><p><strong>4. 尽可能把所有列定义为 NOT NULL</strong><br>原因：</p><p>索引 NULL 列需要额外的空间来保存，所以要占用更多的空间</p><p>进行比较和计算时要对 NULL 值做特别的处理</p><p><strong>5. 使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间</strong></p><p>TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07</p><p>TIMESTAMP 占用 4 字节和 INT 相同，但比 INT 可读性高</p><p>超出 TIMESTAMP 取值范围的使用 DATETIME 类型存储</p><p>经常会有人用字符串存储日期型的数据（不正确的做法）</p><p>•缺点 1：无法用日期函数进行计算和比较<br>•缺点 2：用字符串存储日期要占用更多的空间</p><p><strong>6. 同财务相关的金额类数据必须使用 decimal 类型</strong></p><p>•非精准浮点：float,double<br>•精准浮点：decimal</p><p>Decimal 类型为精准浮点数，在计算时不会丢失精度</p><p>占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节</p><p>可用于存储比 bigint 更大的整型数据</p><h3 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="索引设计规范"></a>索引设计规范</h3><h4 id="限制每张表上的索引数量-建议单张表索引不超过-5-个"><a href="#限制每张表上的索引数量-建议单张表索引不超过-5-个" class="headerlink" title="限制每张表上的索引数量,建议单张表索引不超过 5 个"></a>限制每张表上的索引数量,建议单张表索引不超过 5 个</h4><p>索引并不是越多越好！索引可以提高效率同样可以降低效率。</p><p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。</p><p>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。</p><h4 id="禁止给表中的每一列都建立单独的索引"><a href="#禁止给表中的每一列都建立单独的索引" class="headerlink" title="禁止给表中的每一列都建立单独的索引"></a>禁止给表中的每一列都建立单独的索引</h4><p>5.6 版本之前，一个 sql 只能使用到一个表中的一个索引，5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。</p><h4 id="每个-Innodb-表必须有个主键"><a href="#每个-Innodb-表必须有个主键" class="headerlink" title="每个 Innodb 表必须有个主键"></a>每个 Innodb 表必须有个主键</h4><p>Innodb 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。</p><p>Innodb 是按照主键索引的顺序来组织表的</p><ul><li>不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）</li><li>不要使用 UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）</li><li>主键建议使用自增 ID 值</li></ul><h4 id="4-常见索引列建议"><a href="#4-常见索引列建议" class="headerlink" title="4. 常见索引列建议"></a>4. 常见索引列建议</h4><p>•出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列<br>•包含在 ORDER BY、GROUP BY、DISTINCT 中的字段<br>•并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好<br>•多表 join 的关联列</p><p>####5.如何选择索引列的顺序<br>建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。</p><p>•区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）<br>•尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）<br>•使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）</p><h4 id="避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）"><a href="#避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）" class="headerlink" title="避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）"></a>避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）</h4><p>•重复索引示例：primary key(id)、index(id)、unique index(id)<br>•冗余索引示例：index(a,b,c)、index(a,b)、index(a)</p><h4 id="对于频繁的查询优先考虑使用覆盖索引"><a href="#对于频繁的查询优先考虑使用覆盖索引" class="headerlink" title="对于频繁的查询优先考虑使用覆盖索引"></a>对于频繁的查询优先考虑使用覆盖索引</h4><p>覆盖索引：就是包含了所有查询字段 (where,select,ordery by,group by 包含的字段) 的索引</p><p>覆盖索引的好处：</p><ul><li>避免 Innodb 表进行索引的二次查询: Innodb 是以聚集索引的顺序来存储的，对于 Innodb 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。</li><li>可以把随机 IO 变成顺序 IO 加快查询效率: 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</li></ul><h4 id="8-索引-SET-规范"><a href="#8-索引-SET-规范" class="headerlink" title="8.索引 SET 规范"></a>8.索引 SET 规范</h4><p>尽量避免使用外键约束</p><ul><li>不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引</li><li>外键可用于保证数据的参照完整性，但建议在业务端实现</li><li>外键会影响父表和子表的写操作从而降低性能</li></ul><p>###数据库 SQL 开发规范<br><strong>1. 建议使用预编译语句进行数据库操作</strong></p><p>预编译语句可以重复使用这些计划，减少 SQL 编译所需要的时间，还可以解决动态 SQL 所带来的 SQL 注入的问题。</p><p>只传参数，比传递 SQL 语句更高效。</p><p>相同语句可以一次解析，多次使用，提高处理效率。</p><p><strong>2. 避免数据类型的隐式转换</strong></p><p>隐式转换会导致索引失效如:</p><p>select name,phone from customer where id = ‘111’;</p><p><strong>3. 充分利用表上已经存在的索引</strong></p><p>避免使用双%号的查询条件。如：a like ‘%123%’，（如果无前置%,只有后置%，是可以用到列上的索引的）</p><p>一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。</p><p>在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧，使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。</p><p><strong>4. 数据库设计时，应该要对以后扩展进行考虑</strong></p><p><strong>5. 程序连接不同的数据库使用不同的账号，进制跨库查询</strong></p><ul><li>为数据库迁移和分库分表留出余地</li><li>降低业务耦合度</li><li>避免权限过大而产生的安全风险</li></ul><p>*<em>6. 禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询*</em></p><p>原因：</p><p>•消耗更多的 CPU 和 IO 以网络带宽资源<br>•无法使用覆盖索引<br>•可减少表结构变更带来的影响</p><p><strong>7. 禁止使用不含字段列表的 INSERT 语句</strong></p><p>如：</p><p>insert into values (‘a’,’b’,’c’);<br>应使用：</p><p>insert into t(c1,c2,c3) values (‘a’,’b’,’c’);<br><strong>8. 避免使用子查询，可以把子查询优化为 join 操作</strong></p><p>通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。</p><p>子查询性能差的原因：</p><p>子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p><p>由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</p><p><strong>9. 避免使用 JOIN 关联太多的表</strong></p><p>对于 MySQL 来说，是存在关联缓存的，缓存的大小可以由 join_buffer_size 参数进行设置。</p><p>在 MySQL 中，对于同一个 SQL 多关联（join）一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。</p><p>如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。</p><p>同时对于关联操作来说，会产生临时表操作，影响查询效率，MySQL 最多允许关联 61 个表，建议不超过 5 个。</p><p><strong>10. 减少同数据库的交互次数</strong></p><p>数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率。</p><p><strong>11. 对应同一列进行 or 判断时，使用 in 代替 or</strong></p><p>in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。</p><p><strong>12. 禁止使用 order by rand() 进行随机排序</strong></p><p>order by rand() 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。</p><p>推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。</p><p><strong>13. WHERE 从句中禁止对列进行函数转换和计算</strong></p><p>对列进行函数转换或计算时会导致无法使用索引</p><p>不推荐：</p><p>where date(create_time)=’20190101’<br>推荐：</p><p>where create_time &gt;= ‘20190101’ and create_time &lt; ‘20190102’<br><strong>14. 在明显不会有重复值时使用 UNION ALL 而不是 UNION</strong></p><p>•UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作<br>•UNION ALL 不会再对结果集进行去重操作</p><p><strong>15. 拆分复杂的大 SQL 为多个小 SQL</strong></p><ul><li>大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL</li><li>MySQL 中，一个 SQL 只能使用一个 CPU 进行计算</li><li>SQL 拆分后可以通过并行执行来提高处理效率</li></ul><h3 id="数据库操作行为规范"><a href="#数据库操作行为规范" class="headerlink" title="数据库操作行为规范"></a>数据库操作行为规范</h3><p><strong>1. 超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作</strong></p><p>大批量操作可能会造成严重的主从延迟</p><p>主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间， 而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况</p><p>binlog 日志为 row 格式时会产生大量的日志</p><p>大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因</p><p>避免产生大事务操作</p><p>大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。</p><p>特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批</p><p><strong>2. 对于大表使用 pt-online-schema-change 修改表结构</strong></p><ul><li>避免大表修改产生的主从延迟</li><li>避免在对表字段进行修改时进行锁表</li></ul><p>对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。</p><p>pt-online-schema-change 它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个 DDL 操作，分解成多个小的批次进行。</p><p><strong>3. 禁止为程序使用的账号赋予 super 权限</strong></p><ul><li>当达到最大连接数限制时，还运行 1 个有 super 权限的用户连接</li><li>super 权限只能留给 DBA 处理问题的账号使用</li></ul><p><strong>4. 对于程序连接数据库账号,遵循权限最小原则</strong></p><ul><li>程序使用数据库账号只能在一个 DB 下使用，不准跨库</li><li>程序使用的账号原则上不准有 drop 权限</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Voliate关键字</title>
      <link href="2020/10/01/Voliate%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>2020/10/01/Voliate%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h3 id="voliate关键字"><a href="#voliate关键字" class="headerlink" title="voliate关键字"></a>voliate关键字</h3><p>####1 使变量在线程间可见<br>对于避免不可见性问题，Java还提供了一种弱形式的同步，即使用了volatile关键字。该关键字确保了对一个变量的更新对其他线程可见。当一个变量被声明为volatile时候，线程写入时候不会把值缓存在寄存器或者或者在其他地方，当线程读取的时候会从主内存重新获取最新值，而不是使用当前线程的拷贝内存变量值。volatile虽然提供了可见性保证，但是不能使用他来构建复合的原子性操作，也就是说当一个变量依赖其他变量或者更新变量值时候新值依赖当前老值时候不在适用。与synchronized相似之处在于如图</p><p><img src="https://upload-images.jianshu.io/upload_images/1463524-341008d65746e274.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="avatar"></p><p>如图线程A修改了volatile变量b的值，然后线程B读取了改变量值，那么所有A线程在写入变量b值前可见的变量值，在B读取volatile变量b后对线程B都是可见的，图中线程B对A操作的变量a,b的值都可见的。volatile的内存语义和synchronized有类似之处，具体说是说当线程写入了volatile变量值就等价于线程退出synchronized同步块（会把写入到本地内存的变量值同步到主内存），读取volatile变量值就相当于进入同步块（会先清空本地内存变量值，从主内存获取最新值）。</p><pre><code>```java public class Test extends Thread&#123; //voliateprivate String i =&quot;sss&quot;;private void setI(String i)&#123;    this.i=i;&#125;@Overridepublic void run() &#123;    System.out.println(&quot;进入方法&quot;+i);    while (i.equals(&quot;sss&quot;))&#123;    &#125;    System.out.println(&quot;线程结束&quot;);&#125;public static void main(String[] args ) throws InterruptedException&#123;    Test test=new Test();    test.start();    Thread.sleep(1000);    System.out.println(&quot;线程设置了stop&quot;);    test.setI(&quot;线程设置了stop&quot;); &#125;&#125;```</code></pre><p>上面是一个简单的示例。</p><ol><li>首先运行代码,可以看到,尽管将变量设置了stop,test线程并没有如预期的停止.说明,test线程内的i的并没有被修改,test只是在start时将i变量拷贝到了线程自有的一块空间内,与主线内的i变量互不影响.</li></ol><p>2.将voliate关键字放在变量i的声明上,运行发现程序正常停止.可见变量i在任何一个线程内都是可见的,当变量i在主线程被修改时,子线程立即获得了被更新的值.</p><ol start="3"><li>最坑的地方来了,打开代码中的while循环中的打印语句,将voliate关键字注释掉,执行代码.神奇的事情发生了,程序正常的停止了,WTF!(在我最开始研究voliate的时候,我一直有这句输出语句,一直得不到正确结果)这是为啥呢？下面这段话基本说明了问题,同时你也可以将输出语句注释点,打开sleep的注释,看看结果.</li></ol><p>JVM会尽力保证内存的可见性，即便这个变量没有加同步关键字。换句话说，只要CPU有时间，JVM会尽力去保证变量值的更新。这种与volatile关键字的不同在于，volatile关键字会强制的保证线程的可见性。而不加这个关键字，JVM也会尽力去保证可见性，但是如果CPU一直有其他的事情在处理，它也没办法。最开始的代码，一直处于试了循环中，CPU处于一直被饱受占用的时候，这个时候CPU没有时间，JVM也不能强制要求CPU分点时间去取最新的变量值。而加了System.out.println之后，由于内部代码的同步关键字的存在，导致CPU的输出其实是比较耗时的。这个时候CPU就有可能有时间去保证内存的可见性，于是while循环可以被终止。其实，也可以在while循环里面加上sleep，让run方法放弃cpu，但是不放弃锁，这个时候由于CPU有空闲的时候就去按照JVM的要求去保证内存的可见性。如下图所示。 run方法里面休息了3秒，cpu有充足的空闲时间去取变量的最新值，所以循环执行一次就停止了。</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是AQS及其原理</title>
      <link href="2020/09/12/AQS%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/"/>
      <url>2020/09/12/AQS%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="1、AQS简介"><a href="#1、AQS简介" class="headerlink" title="1、AQS简介"></a>1、AQS简介</h3><p>AQS全名：AbstractQueuedSynchronizer，是并发容器J.U.C（java.lang.concurrent）下locks包内的一个类。它实现了一个FIFO(FirstIn、FisrtOut先进先出)的队列。底层实现的数据结构是一个双向链表。</p><p><img src="https://www.pianshen.com/images/796/7cc7646e4fd1cb94f1cbf6e895725b94.png" alt="avatar"></p><p>Sync queue：同步队列，是一个双向链表。包括head节点和tail节点。head节点主要用作后续的调度。 Condition queue：非必须，单向链表。当程序中存在cindition的时候才会存在此列表。</p><p><strong>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p><p><strong>AQS使用一个int成员变量来表示同步状态</strong>，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。</p><p>状态信息通过procted类型的getState，setState，compareAndSetState进行操作</p><pre><code>```//返回同步状态的当前值 protected final int getState() &#123;       return state; &#125; // 设置同步状态的值 protected final void setState(int newState) &#123;      state = newState;&#125;//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）protected final boolean compareAndSetState(int expect, int update) &#123;   return unsafe.compareAndSwapInt(this, stateOffset, expect, update);&#125;```</code></pre><h3 id="2、AQS设计思想"><a href="#2、AQS设计思想" class="headerlink" title="2、AQS设计思想"></a>2、AQS设计思想</h3><ul><li>使用Node实现FIFO队列，可以用于构建锁或者其他同步装置的基础框架。</li><li>利用int类型标识状态。<strong>在AQS类中有一个叫做state的成员变量</strong></li></ul><p>基于AQS有一个同步组件，叫做ReentrantLock。<strong>在这个组件里，stste表示获取锁的线程数，假如state=0，表示还没有线程获取锁，1表示有线程获取了锁。大于1表示重入锁的数量。</strong></p><p>继承：子类通过继承并通过实现它的方法管理其状态（acquire和release方法操纵状态）。</p><p>可以同时实现排它锁和共享锁模式（独占、共享），站在一个使用者的角度，AQS的功能主要分为两类：<strong>独占和共享</strong>。它的所有子类中，要么实现并使用了它的独占功能的api，要么使用了共享锁的功能，而不会同时使用两套api，即便是最有名的子类ReentrantReadWriteLock也是通过两个内部类读锁和写锁分别实现了两套api来实现的。</p><h3 id="3、AQS的大致实现思路"><a href="#3、AQS的大致实现思路" class="headerlink" title="3、AQS的大致实现思路"></a>3、AQS的大致实现思路</h3><p>AQS内部维护了一个CLH队列来管理锁。<strong>线程会首先尝试获取锁，如果失败就将当前线程及等待状态等信息包装成一个node节点加入到同步队列sync queue里</strong>。 接着会不断的循环尝试获取锁，条件是当前节点为head的直接后继才会尝试。如果失败就会阻塞自己直到自己被唤醒。而当持有锁的线程释放锁的时候，会唤醒队列中的后继线程。</p><p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中CAS详解</title>
      <link href="2020/09/01/Java%E4%B8%ADCAS%E8%AF%A6%E8%A7%A3/"/>
      <url>2020/09/01/Java%E4%B8%ADCAS%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>在JDK 5之前Java语言是靠synchronized关键字保证同步的，这会导致有锁</p><p>锁机制存在以下问题：</p><p>（1）在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</p><p>（2）一个线程持有锁会导致其它所有需要此锁的线程挂起。</p><p>（3）如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。</p><p>volatile是不错的机制，但是volatile不能保证原子性。因此对于同步最终还是要回到锁机制上来。</p><p><strong>独占锁是一种悲观锁，synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁用到的机制就是CAS，Compare and Swap。</strong></p><h3 id="一、什么是CAS"><a href="#一、什么是CAS" class="headerlink" title="一、什么是CAS"></a>一、什么是CAS</h3><p>CAS,compare and swap的缩写，中文翻译成比较并交换。</p><p>我们都知道，在java语言之前，并发就已经广泛存在并在服务器领域得到了大量的应用。所以硬件厂商老早就在芯片中加入了大量直至并发操作的原语，从而在硬件层面提升效率。在intel的CPU中，使用cmpxchg指令。</p><p>在Java发展初期，java语言是不能够利用硬件提供的这些便利来提升系统的性能的。而随着java不断的发展,Java本地方法(JNI)的出现，使得java程序越过JVM直接调用本地方法提供了一种便捷的方式，因而java在并发的手段上也多了起来。而在Doug Lea提供的cucurenct包中，CAS理论是它实现整个java包的基石。</p><p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该 位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”</p><p>通常将 CAS 用于同步的方式是从地址 V 读取值 A，执行多步计算来获得新 值 B，然后使用 CAS 将 V 的值从 A 改为 B。如果 V 处的值尚未同时更改，则 CAS 操作成功。</p><p>类似于 CAS 的指令允许算法执行读-修改-写操作，而无需害怕其他线程同时 修改变量，因为如果其他线程修改变量，那么 CAS 会检测它（并失败），算法 可以对该操作重新计算。</p><h3 id="二、CAS的目的"><a href="#二、CAS的目的" class="headerlink" title="二、CAS的目的"></a>二、CAS的目的</h3><p>利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法。其它原子操作都是利用类似的特性完成的。而整个J.U.C都是建立在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很大的提升。</p><p>三、CAS存在的问题</p><p>CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作</p><p><strong>1.  ABA问题</strong>。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。</p><p>从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><p>**<br>2. 循环时间长开销大**。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p><p><strong>3. 只能保证一个共享变量的原子操作</strong>。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</p><h3 id="四、concurrent包的实现"><a href="#四、concurrent包的实现" class="headerlink" title="四、concurrent包的实现"></a>四、concurrent包的实现</h3><p>由于java的CAS同时具有 volatile 读和volatile写的内存语义，因此Java线程之间的通信现在有了下面四种方式：</p><p>A线程写volatile变量，随后B线程读这个volatile变量。<br>A线程写volatile变量，随后B线程用CAS更新这个volatile变量。<br>A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。<br>A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。<br>Java的CAS会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键（从本质上来说，能够支持原子性读-改-写指令的计算机器，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）。同时，volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式：</p><p>首先，声明共享变量为volatile；<br>然后，使用CAS的原子条件更新来实现线程之间的同步；<br>同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。<br>AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程池详解</title>
      <link href="2020/08/20/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/"/>
      <url>2020/08/20/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>###1、线程池的优势</p><p>（1）、降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；<br>（2）、提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；<br>（3）方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换（cpu切换线程是有时间成本的（需要保持当前执行线程的现场，并恢复要执行线程的现场））。<br>（4）提供更强大的功能，延时定时线程池。</p><h3 id="2、线程池的主要参数"><a href="#2、线程池的主要参数" class="headerlink" title="2、线程池的主要参数"></a>2、线程池的主要参数</h3><pre><code>``` public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123;this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,     Executors.defaultThreadFactory(), defaultHandler);&#125;```</code></pre><p>1、corePoolSize（线程池基本大小）：当向线程池提交一个任务时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于corePoolSize时，（除了利用提交新任务来创建和启动线程（按需构造），也可以通过 prestartCoreThread() 或 prestartAllCoreThreads() 方法来提前启动线程池中的基本线程。）</p><p>2、maximumPoolSize（线程池最大大小）：线程池所允许的最大线程个数。当队列满了，且已创建的线程数小于maximumPoolSize，则线程池会创建新的线程来执行任务。另外，对于无界队列，可忽略该参数。</p><p>3、keepAliveTime（线程存活保持时间）当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。</p><p>4、workQueue（任务队列）：用于传输和保存等待执行任务的阻塞队列。</p><p>5、threadFactory（线程工厂）：用于创建新线程。threadFactory创建的线程也是采用new Thread()方式，threadFactory创建的线程名都具有统一的风格：pool-m-thread-n（m为线程池的编号，n为线程池内的线程编号）。</p><p>5、handler（线程饱和策略）：当线程池和队列都满了，再加入线程会执行此策略。</p><h3 id="3、线程池流程"><a href="#3、线程池流程" class="headerlink" title="3、线程池流程"></a>3、线程池流程</h3><p><img src="https://upload-images.jianshu.io/upload_images/6024478-88ee7b20f8f45825.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/937/format/webp" alt="avatar"></p><p>1、判断核心线程池是否已满，没满则创建一个新的工作线程来执行任务。已满则。<br>2、判断任务队列是否已满，没满则将新提交的任务添加在工作队列，已满则。<br>3、判断整个线程池是否已满，没满则创建一个新的工作线程来执行任务，已满则执行饱和策略。</p><p>（1、判断线程池中当前线程数是否大于核心线程数，如果小于，在创建一个新的线程来执行任务，如果大于则<br>2、判断任务队列是否已满，没满则将新提交的任务添加在工作队列，已满则。<br>3、判断线程池中当前线程数是否大于最大线程数，如果小于，则创建一个新的线程来执行任务，如果大于，则执行饱和策略。）</p><h3 id="4、线程池为什么需要使用（阻塞）队列？"><a href="#4、线程池为什么需要使用（阻塞）队列？" class="headerlink" title="4、线程池为什么需要使用（阻塞）队列？"></a>4、线程池为什么需要使用（阻塞）队列？</h3><p>回到了非线程池缺点中的第3点：<br>1、因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换。</p><p>另外回到了非线程池缺点中的第1点：<br>2、创建线程池的消耗较高。<br>或者下面这个网上并不高明的回答：<br>2、线程池创建线程需要获取mainlock这个全局锁，影响并发效率，阻塞队列可以很好的缓冲。</p><h3 id="5、线程池为什么要使用阻塞队列而不使用非阻塞队列？"><a href="#5、线程池为什么要使用阻塞队列而不使用非阻塞队列？" class="headerlink" title="5、线程池为什么要使用阻塞队列而不使用非阻塞队列？"></a>5、线程池为什么要使用阻塞队列而不使用非阻塞队列？</h3><p>阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使得线程进入wait状态，释放cpu资源。<br>当队列中有任务时才唤醒对应线程从队列中取出消息进行执行。<br>使得在线程不至于一直占用cpu资源。</p><p>（线程执行完任务后通过循环再次从任务队列中取出任务进行执行，代码片段如下<br>while (task != null || (task = getTask()) != null) {}）。</p><p>不用阻塞队列也是可以的，不过实现起来比较麻烦而已，有好用的为啥不用呢？</p><h3 id="6-如何配置线程池"><a href="#6-如何配置线程池" class="headerlink" title="6.如何配置线程池"></a>6.如何配置线程池</h3><p>CPU密集型任务<br>尽量使用较小的线程池，一般为CPU核心数+1。 因为CPU密集型任务使得CPU使用率很高，若开过多的线程数，会造成CPU过度切换。</p><p>IO密集型任务<br>可以使用稍大的线程池，一般为2*CPU核心数。 IO密集型任务CPU使用率并不高，因此可以让CPU在等待IO的时候有其他线程去处理别的任务，充分利用CPU时间。</p><p>混合型任务<br>可以将任务分成IO密集型和CPU密集型任务，然后分别用不同的线程池去处理。 只要分完之后两个任务的执行时间相差不大，那么就会比串行执行来的高效。<br>因为如果划分之后两个任务执行时间有数据级的差距，那么拆分没有意义。<br>因为先执行完的任务就要等后执行完的任务，最终的时间仍然取决于后执行完的任务，而且还要加上任务拆分与合并的开销，得不偿失。</p><h3 id="7、java中提供的线程池"><a href="#7、java中提供的线程池" class="headerlink" title="7、java中提供的线程池"></a>7、java中提供的线程池</h3><p>Executors类提供了4种不同的线程池：newCachedThreadPool, newFixedThreadPool, newScheduledThreadPool, newSingleThreadExecutor</p><p>1、newCachedThreadPool：用来创建一个可以无限扩大的线程池，适用于负载较轻的场景，执行短期异步任务。（可以使得任务快速得到执行，因为任务时间执行短，可以很快结束，也不会造成cpu过度切换）</p><p>2、newFixedThreadPool：创建一个固定大小的线程池，因为采用无界的阻塞队列，所以实际线程数量永远不会变化，适用于负载较重的场景，对当前线程数量进行限制。（保证线程数可控，不会造成线程过多，导致系统负载更为严重）</p><p>3、newSingleThreadExecutor：创建一个单线程的线程池，适用于需要保证顺序执行各个任务。</p><p>4、newScheduledThreadPool：适用于执行延时或者周期性任务。</p><h3 id="8、execute-和submit-方法"><a href="#8、execute-和submit-方法" class="headerlink" title="8、execute()和submit()方法"></a>8、execute()和submit()方法</h3><p>1、execute()，执行一个任务，没有返回值。<br>2、submit()，提交一个线程任务，有返回值。<br>submit(Callable<T> task)能获取到它的返回值，通过future.get()获取（阻塞直到任务执行完）。一般使用FutureTask+Callable配合使用（IntentService中有体现）。</p><p>submit(Runnable task, T result)能通过传入的载体result间接获得线程的返回值。<br>submit(Runnable task)则是没有返回值的，就算获取它的返回值也是null。</p><p>Future.get方法会使取结果的线程进入阻塞状态，知道线程执行完成之后，唤醒取结果的线程，然后返回结果。</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程的挑战</title>
      <link href="2020/08/15/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8C%91%E6%88%98/"/>
      <url>2020/08/15/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8C%91%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p>1、上下文切换的问题</p><p>2、死锁的问题、</p><p>3、受限于硬件和软件的资源问题</p><p>一、上下文切换问题</p><p>单核处理器也支持多线程执行代码，cpu通过给每个线程分配cpu时间片来实现这个机制，时间片非常短，需要不停的切换线程执行，让我们感觉多线程是同时执行的，时间片一般是几十毫秒</p><p>查看上下文切换状态：</p><blockquote><p>**grep java.lang.Thread.State dump305 | awk ‘{print $2$3$4$5}’ | sort | uniq -c  **</p></blockquote><p>任务从保存到再加载的过程就是一次上下文切换，上下文切换会影响多线程的执行速度</p><p>如何减少上下文切换？</p><p>1、无锁并发编程</p><p>可以用一些方法来避免使用锁，如将数据的ID按照哈希算法取模分段，不同的线程处理不同段的数据</p><p>2、CAS算法</p><p>3、使用最少线程和使用协程</p><p>在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换</p><p>避免死锁的几个常见方法</p><p>1、避免一个线程同时获取多个锁</p><p>2、避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源</p><p>3、尝试使用定时锁，使用lock.tryLcok(timeout)来替代使用内部锁机制</p><p>4、对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况</p><p>资源限制</p><p>硬件资源限制：带宽的上传下载速度、硬盘的读写速度、CPU的处理速度、</p><p>解决方案：可以使用集群并行执行程序</p><p>软件资源限制：数据库的连接数、socket的连接数</p><p>解决方案：可以使用资源池将资源复用，如数据库的连接池和Socket复用，或者在调用对方的webservice接口的时候，只建立一个连接</p><p>在资源限制的情况下进行并发编程</p><p>根据不同的资源，限制调整程序的并发度，如下载文件程序依赖于带宽和磁盘读写速度，有数据库操作时候，涉及到数据库的连接数，如果sql执行非常快，而线程的数量比数据库连接数大很多，则某些线程会被阻塞，等待数据库的连接。</p><p>CPU飙升到100%，有可能是不恰当的并发程序引起的</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发机制的底层实现原理</title>
      <link href="2020/08/01/Java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>2020/08/01/Java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>java中所使用的并发机制依赖于jvm的实现和cpu的指令</p><p>volatile</p><p>volatile是轻量级的synchronized，如果这个修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为他不会引起线程上下文的切换和调度</p><p>定义：java允许线程访问共享变量，为了确保共享变量能被准确和一致性的更新，线程应该确保通过排他锁单独获得这个变量，如果一个字段被设置成volatile，java线程内存模型确保所以线程看到的这个变量的值是一致的</p><p>lock前缀的指令在多核处理器下会做两件事：</p><p>1）将当前处理器缓存行的数据写回到系统内存</p><p>2）这个写回内存的操作会使在其他cpu里面缓存了该内存地址的数据无效</p><p>当使用volatile修饰的变量进行写操作的时候，jvm就会向处理器发送一条lock前缀的指令，通过缓存一致性协议，每个处理器嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读取到缓存里</p><p>volatile的两条实现规则</p><p>（1）lock前缀指令会引起处理器缓存回写到内存</p><p>（2）一个处理器的缓存回写到内存会导致其他的处理器的缓存无效</p><p>volatile的优化</p><p>LinkedTransferQueue通过追加成64字节的方式提高效率，因为很多处理器的高速缓存行都是64字节，如果不追加空的字节会把头节点和尾节点放到一个缓存行，导致修改的时候缓存锁定，入队和出队不能同时操作而相互锁定</p><p>以下两种场景不应该把volatile变量追加到64字节</p><p>1）缓存行非64字节的处理器</p><p>2）共享变量不会被频繁的写</p><p>这种追加字节的方式在java7中不可能生效，因为会淘汰或者重新排序无用的字段，需要使用其他追加字节的方式</p><p>synchronized</p><p>对于普通的同步方法 锁的是当前实例的对象</p><p>对于静态的同步方法锁的是当前类的class对象</p><p>对于同步代码块 锁的是括号里的对象</p><p>jvm基于进入和退出Monitor对象来实现方法同步和代码块同步</p><p>synchronized用的锁是存在于java对象头里面的，如果对象是数组类型，则虚拟机用三个字宽存储对象头，如果对象是非数组类型，则使用2个字宽存储对象头，在32位的虚拟机中，一字宽是32bit，即4字节</p><p><img src="https://img-blog.csdnimg.cn/20191029180701482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbjg4ODg4ODg4ODg4ODg4ODg4,size_16,color_FFFFFF,t_70" alt="avatar"></p><p>Mark Word 默认存储对象的hashcode，分代年龄和锁标记位，32位的jvm的 Mark Word 默认存储如下所示</p><p><img src="https://img-blog.csdnimg.cn/20191029180914348.png" alt="avatar"></p><p>Mark Word里面的数据会随着运行而变化，可能有以下四种情况<br><img src="https://img-blog.csdnimg.cn/2019102918132359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbjg4ODg4ODg4ODg4ODg4ODg4,size_16,color_FFFFFF,t_70" alt="avatar"></p><p> 64位的存储结构</p><p><img src="https://img-blog.csdnimg.cn/20191029183211209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbjg4ODg4ODg4ODg4ODg4ODg4,size_16,color_FFFFFF,t_70" alt="avatar"></p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存划分</title>
      <link href="2020/07/12/JVM%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/"/>
      <url>2020/07/12/JVM%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>###1. 概述<br>对于Java程序员，在虚拟机自动内存管理机制的帮助下，不再需要为每个new操作去写配对的delete/free代码，不容易出现内存泄漏和内存溢出问题。</p><h3 id="2-运行时数据区域"><a href="#2-运行时数据区域" class="headerlink" title="2. 运行时数据区域"></a>2. 运行时数据区域</h3><p>Java虚拟机在执行Java程序的过程中会把它管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范（Java SE 7版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域：程序计数器，Java虚拟机栈，本地方法栈，Java堆，方法区。</p><p>下图为各个区域以及进一步细化图：</p><p><img src="https://images2018.cnblogs.com/blog/563799/201804/563799-20180424161205943-784876438.png" alt="avatar"></p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p><strong>程序计数器（Program Counter Register）是一块较小的内存空间，可以看做当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</strong></p><p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，每个线程之间计数器互不影响，独立存储。</p><p>备注：</p><p>（a）如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器的值则为空。</p><p>（b）此内存区域是唯一在Java虚拟机规范中没有规定任何OOM情况的区域。</p><h4 id="2-2-Java虚拟机栈"><a href="#2-2-Java虚拟机栈" class="headerlink" title="2.2 Java虚拟机栈"></a>2.2 Java虚拟机栈</h4><p>Java Virtual Machine Stacks，也是线程私有的，它的生命周期与线程相同。</p><p>虚拟机栈描述的是<strong>Java方法执行的内存模型（非native方法）</strong>。</p><p>每个方法在执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。</p><p>每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程，当方法被调用则入栈，一旦完成调用则出栈。所有的栈帧都出栈后，线程就结束了。</p><p>局部变量表存放了编译器可知的各种<strong>基本数据类型、对象引用、returnAddress类型</strong>。局部变量表所需的内存空间在编译器完成分配。当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><p><strong>基本类型</strong>：boolean, byte, char, short, int, float, long, double，其中long和double占用2个局部变量空间slot其余的占用1个；</p><p><strong>对象引用</strong>：reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置；</p><p><strong>returnAddress类型</strong>：指向了一条字节码指令的地址；</p><p>在Java虚拟机规范中，对这个区域规定了两种异常：线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（目前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，抛出OutOfMemoryError异常。</p><h4 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3 本地方法栈"></a>2.3 本地方法栈</h4><p>Native Method Stack与虚拟机栈的作用非常相似，区别是：虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法。</p><p>备注：HotSpot直接把本地方法栈和虚拟机栈合二为一。本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p><h4 id="2-4-Java堆"><a href="#2-4-Java堆" class="headerlink" title="2.4 Java堆"></a>2.4 Java堆</h4><p>Java Heap是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此区域的唯一目的就是存放对象实例（Java虚拟机规范中的描述时：所有的对象实例以及数组都要在堆上分配）。</p><p>Java堆是GC的主要区域，因此很多时候也被称为GC堆。</p><p><strong>从内存分配的角度来看</strong>，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer, TLAB）</p><p><strong>从内存回收的角度来看</strong>，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代，在细致一点的有Eden空间，From Survivor空间，To Survivor空间等。</p><p>备注：有OOM异常</p><h4 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h4><p><strong>Method Area是各个线程共享内存区域，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。</strong></p><p>在HtoSpot虚拟机中该区域叫永久代，即方法区是虚拟机规范，而永久代是HotSpot实现的方法区。</p><p>绝大部分Java 程序员应该都见过 “java.lang.OutOfMemoryError: PermGen space “这个异常。这里的 “PermGen space”其实指的就是方法区（永久代）。不过方法区和“PermGen space”又有着本质的区别。前者是 JVM 的规范，而后者则是JVM 规范的一种实现，并且只有 HotSpot 才有 “PermGen space”，而对于其他类型的虚拟机，如JRockit（Oracle）、J9（IBM）并没有“PermGen space”。</p><p>注：从JDK7开始永久代的移除工作，存储在永久代的一部分数据已经转移到了Java Heap或者是Native Heap。但永久代仍然存在于JDK7，并没有完全的移除：符号引用(Symbols)转移到了native heap;字面量(interned strings)转移到了java heap;类的静态变量(class statics)转移到了java heap。</p><p>备注：有OOM异常</p><h3 id="2-6-补充"><a href="#2-6-补充" class="headerlink" title="2.6 补充"></a>2.6 补充</h3><h4 id="2-6-1-运行时常量池和Class文件常量池"><a href="#2-6-1-运行时常量池和Class文件常量池" class="headerlink" title="2.6.1 运行时常量池和Class文件常量池"></a>2.6.1 运行时常量池和Class文件常量池</h4><p>Runtime Constant Pool是方法区的一部分。Class文件中除了有类的版本，字段，方法，接口等描述信息，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性。</p><p>备注：有OOM异常</p><h4 id="2-6-2-直接内存"><a href="#2-6-2-直接内存" class="headerlink" title="2.6.2 直接内存"></a>2.6.2 直接内存</h4><p>Direct Memory，并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。</p><p>在jdk1.4加入的NIO类，引入了一种基于通道（Chanel）与缓冲区（Buffer）的IO方式，<strong>它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。</strong>这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><p>备注：本机直接内存的分配不会受到Java堆大小的限制，受到本机总内存和处理器寻址空间的限制，有OOM异常。</p><h3 id="3-HotSpot虚拟机"><a href="#3-HotSpot虚拟机" class="headerlink" title="3. HotSpot虚拟机"></a>3. HotSpot虚拟机</h3><h4 id="3-1-内存划分"><a href="#3-1-内存划分" class="headerlink" title="3.1 内存划分"></a>3.1 内存划分</h4><p>根据JVM规范，内存可分为：<strong>虚拟机栈，本地方法栈，堆，方法区，程序计数器</strong>五个部分。</p><p>但是各种虚拟机HotSpot，JRockit实现却与JVM不尽相同。</p><p>HotSpot主要有：<strong>虚拟机栈，堆，程序计数器，Metaspace，直接内存</strong>四个部分。</p><p>如下为JDK8的内存划分：</p><p><img src="https://images2018.cnblogs.com/blog/563799/201804/563799-20180424161205943-784876438.png" alt="avatar"></p><p>其中，元空间（Metaspace）的本质和永久代类似，都是对JVM规范中方法区的实现。</p><p>不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。</p><p>因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：</p><p>-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。<br>-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。</p><h3 id="3-2-对象的创建、内存布局、访问定位"><a href="#3-2-对象的创建、内存布局、访问定位" class="headerlink" title="3.2 对象的创建、内存布局、访问定位"></a>3.2 对象的创建、内存布局、访问定位</h3><p>基于虚拟机HotSpot深入探讨Java堆中对象分配、布局和访问的全过程。</p><h4 id="3-2-1-对象的创建"><a href="#3-2-1-对象的创建" class="headerlink" title="3.2.1 对象的创建"></a>3.2.1 对象的创建</h4><p>（1）虚拟机遇到new指令后，首先检查new指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否被加载，解析和初始化过。如果没有，那必须先执行类的加载过程；</p><p>（2）类加载检查通过之后，虚拟机将为新生对象分配内存（<strong>对象所需内存的大小在类加载完成后可完全确定</strong>）；</p><p>（3）内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值；</p><p>（4）对对象进行必要的设置，例如这个对象是哪个类的实例，如果才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄等信息（这些对象存放在对象的对象头Object Header中）</p><p>（5）执行init方法，把对象按照程序员的意愿进行初始化。</p><p>有<strong>指针碰撞和空闲列表</strong>两种分配方式：选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的GC是否带有压缩整理功能决定；因此，在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法时指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。</p><p>此外还有对象创建的并发问题：</p><p>（1）堆分配内存空间的动作进行同步处理–采用CAS配上失败重试的方式保证更新操作的原子性；</p><p>（2）把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓存（Thread Local Allocation Buffer,TLAB）</p><p><strong>注：指针碰撞：内存是规整的，空闲列表：内存不是规整的</strong></p><h4 id="3-2-2-对象的内存布局"><a href="#3-2-2-对象的内存布局" class="headerlink" title="3.2.2 对象的内存布局"></a>3.2.2 对象的内存布局</h4><p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头、实例数据、对齐填充。</p><p>如图：<br><img src="https://images2018.cnblogs.com/blog/563799/201804/563799-20180424165642779-735642794.png" alt="avatar"></p><ol><li>对象头（存储在堆）包括两部分：<br>（1）存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标识，线程持有的锁，偏向线程ID，偏向时间戳等，官方称为Mark Word。Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。</li></ol><p>（2）类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><ol start="2"><li><p>实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。</p></li><li><p>对齐填充并不是必然存在的，也没有特别的含义。HotSpot自动内存管理系统要求对象起始地址必须是8字节的倍数，也就是说对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数，因此，当对象实例数据不符没有对齐时，就需要通过对齐填充来补全。</p></li></ol><h4 id="3-2-3-对象的访问定位"><a href="#3-2-3-对象的访问定位" class="headerlink" title="3.2.3 对象的访问定位"></a>3.2.3 对象的访问定位</h4><p>Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范中规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位，访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而言的。目前主流的访问方式有使用<strong>句柄</strong>和<strong>直接指针</strong>两种。</p><p>（1）句柄访问</p><p>Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。</p><p>（2）直接指针，reference中存储的是对象地址，而对象实例的对象头中有类型指针，指向类型数据。</p><p><img src="https://images2017.cnblogs.com/blog/563799/201710/563799-20171019171310146-817535230.png" alt="avatar"></p><p>两种对象访问各有优势，使用句柄来访问的最大好处是reference中存储的是稳定的句柄地址，对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。</p><p>直接指针最大好处就是速度更快，节省了一次指针定位的时间开销。<br><strong>HotSpot使用了直接指针方式进行对象访问。</strong></p><p>备注：reference应该指向堆中Java对象的内存地址，而对象的内存布局里面包括：对象头和对象数据，对象头里面有对象类型指针。</p><h3 id="4-OOM"><a href="#4-OOM" class="headerlink" title="4. OOM"></a>4. OOM</h3><p>OOM：OutOfMemoryError异常</p><p>在Java虚拟机规范中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OOM异常的可能。</p><p>下面的代码都是基于JDK1.8，因此对<strong>堆，虚拟机栈，Metaspace和直接内存</strong>做验证和分析。</p><h4 id="4-1-堆OOM"><a href="#4-1-堆OOM" class="headerlink" title="4.1 堆OOM"></a>4.1 堆OOM</h4><p>代码:</p><pre><code>import java.util.ArrayList; import java.util.List; /**   * VM -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError   *   */ public class HeapOOM &#123;     public static void main(String[] args) &#123;    List&lt;HeapOOM&gt; list = new ArrayList&lt;HeapOOM&gt;();    while(true)        list.add(new HeapOOM());&#125;&#125; </code></pre><p>-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</p><p>Java堆的大小为20MB，不可扩展；通过参数-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照。</p><p>运行结果：</p><p><img src="https://images2018.cnblogs.com/blog/563799/201804/563799-20180424172145047-1935669708.png" alt="avatar"></p><h4 id="4-2-虚拟机栈OOM"><a href="#4-2-虚拟机栈OOM" class="headerlink" title="4.2 虚拟机栈OOM"></a>4.2 虚拟机栈OOM</h4><p>HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，统一是虚拟机栈。</p><p>栈容量只由-Xss参数设定。</p><p>在Java虚拟机规范中描述了2种异常：</p><p>（1）如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常；</p><p>（2）如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OOM。</p><p>代码:</p><pre><code>/**   * VM -Xss108k   * */  public class JavaVMStackSOF &#123;      private int stackLength = 1;      public void stackLeak() &#123;      stackLength++;      stackLeak();&#125; public static void main(String[] args) &#123;    JavaVMStackSOF oom = new JavaVMStackSOF();    try &#123;        oom.stackLeak();    &#125; catch (Throwable t) &#123;        System.out.println(oom.stackLength);        throw t;    &#125; &#125;&#125;　</code></pre><p>-Xss指定栈内存容量。</p><p>运行结果：</p><p><img src="https://images2018.cnblogs.com/blog/563799/201804/563799-20180424190147259-1583450039.png" alt="avatar"></p><h3 id="4-3-元空间OOM"><a href="#4-3-元空间OOM" class="headerlink" title="4.3 元空间OOM"></a>4.3 元空间OOM</h3><h3 id="4-4-直接内存OOM"><a href="#4-4-直接内存OOM" class="headerlink" title="4.4 直接内存OOM"></a>4.4 直接内存OOM</h3><h3 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5 参考资料"></a>5 参考资料</h3><p>深入理解Java虚拟机：JVM高级特性与最佳实践（第二版）</p><p>　</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载机制</title>
      <link href="2020/06/11/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>2020/06/11/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="1、什么是类的加载"><a href="#1、什么是类的加载" class="headerlink" title="1、什么是类的加载"></a>1、什么是类的加载</h3><p>&emsp;&emsp;类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的<strong>方法区</strong>内，然后在<strong>堆</strong>区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的 Class对象， Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p><p><img src="https://images2015.cnblogs.com/blog/331425/201606/331425-20160621125941772-1913742708.png" alt="avatar"></p><p>&emsp;&emsp;类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误</p><p>####加载.class文件的方式</p><ul><li><p>从本地系统中直接加载</p></li><li><p>通过网络下载.class文件</p></li><li><p>从zip，jar等归档文件中加载.class文件</p></li><li><p>从专有数据库中提取.class文件</p></li><li><p>将Java源文件动态编译为.class文件</p></li></ul><h3 id="2、类的生命周期"><a href="#2、类的生命周期" class="headerlink" title="2、类的生命周期"></a>2、类的生命周期</h3><p><img src="https://images2015.cnblogs.com/blog/331425/201606/331425-20160621125943209-1443333281.png" alt="avatar"></p><p>&emsp;&emsp;其中类加载的过程包括了<font color=#0099ff face="黑体">加载、验证、准备、解析、初始化</font>  五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>&emsp;&emsp;查找并加载类的二进制数据加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p><ol><li><p>通过一个类的全限定名来获取其定义的二进制字节流。</p></li><li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p></li><li><p>在Java堆中生成一个代表这个类的 java.lang.Class对象，作为对方法区中这些数据的访问入口。</p></li></ol><p>&emsp;&emsp;相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><p>&emsp;&emsp;加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。</p><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p><strong>验证：确保被加载的类的正确性</strong></p><p>&emsp;&emsp;验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p><p><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范；例如：是否以 0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</p><p><strong>元数据验证</strong>：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object之外。</p><p><strong>字节码验证</strong>：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p><p><strong>符号引用验证</strong>：确保解析动作能正确执行。</p><p>&emsp;&emsp;验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><p><strong>准备：为类的</strong> 静态变量分<strong>配内存，并将其初始化为默认值</strong></p><p>&emsp;&emsp;准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p><ul><li><p>1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</p></li><li><p>2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</p></li></ul><p>&emsp;&emsp;假设一个类变量的定义为： <code>publicstaticintvalue=3；</code></p><p>&emsp;&emsp;那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的 publicstatic指令是在程序编译后，存放于类构造器 <clinit>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</p><blockquote><p>这里还需要注意如下几点：</p></blockquote><blockquote><ul><li>对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li></ul></blockquote><blockquote><ul><li>对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li></ul></blockquote><blockquote><ul><li>对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。</li></ul></blockquote><blockquote><ul><li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li></ul></blockquote><p>3、如果类字段的字段属性表中存在 <code>ConstantValue</code>属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。</p><p>假设上面的类变量value被定义为： <code>publicstaticfinalintvalue=3；</code></p><p>&emsp;&emsp;编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据 ConstantValue的设置将value赋值为3。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中</p><p><strong>解析：把类中的符号引用转换为直接引用</strong></p><p>&emsp;&emsp;解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p><p>&emsp;&emsp;直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><p><strong>初始化</strong></p><p>&emsp;&emsp;初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p><ul><li><p>①声明类变量是指定初始值</p></li><li><p>②使用静态代码块为类变量指定初始值</p></li></ul><p>JVM初始化步骤</p><ul><li><p>1、假如这个类还没有被加载和连接，则程序先加载并连接该类</p></li><li><p>2、假如该类的直接父类还没有被初始化，则先初始化其直接父类</p></li><li><p>3、假如类中有初始化语句，则系统依次执行这些初始化语句</p></li></ul><p>&emsp;&emsp;类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p><ul><li><p>创建类的实例，也就是new的方式</p></li><li><p>访问某个类或接口的静态变量，或者对该静态变量赋值</p></li><li><p>调用类的静态方法</p></li><li><p>反射（如 Class.forName(“com.shengsiyuan.Test”)）</p></li><li><p>初始化某个类的子类，则其父类也会被初始化</p></li><li><p>Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类</p></li></ul><p><strong>结束生命周期</strong></p><p>&emsp;&emsp;在如下几种情况下，Java虚拟机将结束生命周期</p><ul><li><p>执行了 <code>System.exit()</code>方法</p></li><li><p>程序正常执行结束</p></li><li><p>程序在执行过程中遇到了异常或错误而异常终止</p></li><li><p>由于操作系统出现错误而导致Java虚拟机进程终止</p></li></ul><p><strong>3、类加载器</strong><br>寻找类加载器，先来一个小例子</p><pre><code>``` package com.neo.classloader; public class ClassLoaderTest&#123;   public static void main(String[] args)&#123;      ClassLoader loader = Thread.currentThread().getContextClassLoader();      System.out.printIn(loader);      System.out.printIn(loader.getParent());      System.out.printIn(loader.getParent().getParent());   &#125; &#125;​```</code></pre><p>运行后，输出结果：</p><pre><code>``` sun.misc.Launcher$AppClassLoader@64fef26a sun.misc.Launcher$ExtClassLoader@1ddd40f3 null ```</code></pre><p>&emsp;&emsp;从上面的结果可以看出，并没有获取到 ExtClassLoader的父Loader，原因是 BootstrapLoader（引导类加载器）是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回null。</p><p>&emsp;&emsp;这几种类加载器的层次关系如下图所示：</p><p><img src="https://images2015.cnblogs.com/blog/331425/201606/331425-20160621125944459-1013316302.jpg" alt="avatar"></p><blockquote><p>注意：这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。</p></blockquote><p>&emsp;&emsp;站在Java虚拟机的角度来讲，只存在两种不同的类加载器：启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；所有其它的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类 <code>java.lang.ClassLoader</code>，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p><p>&emsp;&emsp;站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</p><p><strong>启动类加载器：</strong> BootstrapClassLoader，负责加载存放在 JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被 -Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被 BootstrapClassLoader加载）。启动类加载器是无法被Java程序直接引用的。</p><p><strong>扩展类加载器：</strong> ExtensionClassLoader，该加载器由 sun.misc.Launcher$ExtClassLoader实现，它负责加载 JDK\jre\lib\ext目录中，或者由 java.ext.dirs系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。</p><p><strong>应用程序类加载器：</strong> ApplicationClassLoader，该类加载器由 sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><p>&emsp;&emsp;应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p><ul><li><p>1、在执行非置信代码之前，自动验证数字签名。</p></li><li><p>2、动态地创建符合用户特定需要的定制化构建类。</p></li><li><p>3、从特定的场所取得java class，例如数据库中和网络中。</p></li></ul><p>JVM类加载机制</p><ul><li><p><strong>全盘负责</strong>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p></li><li><p><strong>父类委托</strong>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p></li><li><p><strong>缓存机制</strong>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p></li></ul><p><strong>4、类的加载</strong><br>类加载有三种方式：</p><p>1、命令行启动应用时候由JVM初始化加载</p><p>2、通过Class.forName()方法动态加载</p><p>3、通过ClassLoader.loadClass()方法动态加载</p><p><strong>Class.forName()和ClassLoader.loadClass()区别</strong></p><ul><li><p><code>Class.forName()</code>：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</p></li><li><p><code>ClassLoader.loadClass()</code>：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</p></li><li><p><code>Class.forName(name,initialize,loader)</code>带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。</p></li></ul><p><strong>5、双亲委派模型</strong></p><p>&emsp;&emsp;双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p><p>双亲委派机制:</p><p>1、当 <code>AppClassLoader</code>加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</p><p>2、当 <code>ExtClassLoader</code>加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader```去完成。</p><p>3、如果 <code>BootStrapClassLoader</code>加载失败（例如在 <code>$JAVA_HOME/jre/lib</code>里未查找到该class），会使用 ExtClassLoader来尝试加载；</p><p>4、若ExtClassLoader也加载失败，则会使用 <code>AppClassLoader</code>来加载，如果 <code>AppClassLoader</code>也加载失败，则会报出异常 <code>ClassNotFoundException</code>。</p><p>双亲委派模型意义：</p><ul><li><p>系统类防止内存中出现多份同样的字节码</p></li><li><p>保证Java程序安全稳定运行</p></li></ul><p><strong>6、自定义类加载器</strong></p><p>&emsp;&emsp;通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自 ClassLoader类，从上面对 loadClass方法来分析来看，我们只需要重写 findClass 方法即可。</p><p>&emsp;&emsp;自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，我并未对class文件进行加密，因此没有解密的过程。这里有几点需要注意：</p><ul><li><p>1、这里传递的文件名需要是类的全限定性名称，即 <code>com.paddx.test.classloading.Test</code>格式的，因为 defineClass 方法是按这种格式进行处理的。</p></li><li><p>2、最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。</p></li><li><p>3、这类Test 类本身可以被 <code>AppClassLoader</code>类加载，因此我们不能把 <code>com/paddx/test/classloading/Test.class</code>放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由 AppClassLoader加载，而不会通过我们自定义类加载器来加载。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

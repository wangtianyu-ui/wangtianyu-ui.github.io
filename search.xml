<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JVM内存划分</title>
      <link href="2020/07/12/JVM%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/"/>
      <url>2020/07/12/JVM%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>###1. 概述<br>对于Java程序员，在虚拟机自动内存管理机制的帮助下，不再需要为每个new操作去写配对的delete/free代码，不容易出现内存泄漏和内存溢出问题。</p><h3 id="2-运行时数据区域"><a href="#2-运行时数据区域" class="headerlink" title="2. 运行时数据区域"></a>2. 运行时数据区域</h3><p>Java虚拟机在执行Java程序的过程中会把它管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范（Java SE 7版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域：程序计数器，Java虚拟机栈，本地方法栈，Java堆，方法区。</p><p>下图为各个区域以及进一步细化图：</p><p><img src="https://images2018.cnblogs.com/blog/563799/201804/563799-20180424161205943-784876438.png" alt="avatar"></p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p><strong>程序计数器（Program Counter Register）是一块较小的内存空间，可以看做当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</strong></p><p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，每个线程之间计数器互不影响，独立存储。</p><p>备注：</p><p>（a）如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器的值则为空。</p><p>（b）此内存区域是唯一在Java虚拟机规范中没有规定任何OOM情况的区域。</p><h4 id="2-2-Java虚拟机栈"><a href="#2-2-Java虚拟机栈" class="headerlink" title="2.2 Java虚拟机栈"></a>2.2 Java虚拟机栈</h4><p>Java Virtual Machine Stacks，也是线程私有的，它的生命周期与线程相同。</p><p>虚拟机栈描述的是<strong>Java方法执行的内存模型（非native方法）</strong>。</p><p>每个方法在执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。</p><p>每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程，当方法被调用则入栈，一旦完成调用则出栈。所有的栈帧都出栈后，线程就结束了。</p><p>局部变量表存放了编译器可知的各种<strong>基本数据类型、对象引用、returnAddress类型</strong>。局部变量表所需的内存空间在编译器完成分配。当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><p><strong>基本类型</strong>：boolean, byte, char, short, int, float, long, double，其中long和double占用2个局部变量空间slot其余的占用1个；</p><p><strong>对象引用</strong>：reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置；</p><p><strong>returnAddress类型</strong>：指向了一条字节码指令的地址；</p><p>在Java虚拟机规范中，对这个区域规定了两种异常：线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（目前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，抛出OutOfMemoryError异常。</p><h4 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3 本地方法栈"></a>2.3 本地方法栈</h4><p>Native Method Stack与虚拟机栈的作用非常相似，区别是：虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法。</p><p>备注：HotSpot直接把本地方法栈和虚拟机栈合二为一。本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p><h4 id="2-4-Java堆"><a href="#2-4-Java堆" class="headerlink" title="2.4 Java堆"></a>2.4 Java堆</h4><p>Java Heap是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此区域的唯一目的就是存放对象实例（Java虚拟机规范中的描述时：所有的对象实例以及数组都要在堆上分配）。</p><p>Java堆是GC的主要区域，因此很多时候也被称为GC堆。</p><p><strong>从内存分配的角度来看</strong>，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer, TLAB）</p><p><strong>从内存回收的角度来看</strong>，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代，在细致一点的有Eden空间，From Survivor空间，To Survivor空间等。</p><p>备注：有OOM异常</p><h4 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h4><p><strong>Method Area是各个线程共享内存区域，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。</strong></p><p>在HtoSpot虚拟机中该区域叫永久代，即方法区是虚拟机规范，而永久代是HotSpot实现的方法区。</p><p>绝大部分Java 程序员应该都见过 “java.lang.OutOfMemoryError: PermGen space “这个异常。这里的 “PermGen space”其实指的就是方法区（永久代）。不过方法区和“PermGen space”又有着本质的区别。前者是 JVM 的规范，而后者则是JVM 规范的一种实现，并且只有 HotSpot 才有 “PermGen space”，而对于其他类型的虚拟机，如JRockit（Oracle）、J9（IBM）并没有“PermGen space”。</p><p>注：从JDK7开始永久代的移除工作，存储在永久代的一部分数据已经转移到了Java Heap或者是Native Heap。但永久代仍然存在于JDK7，并没有完全的移除：符号引用(Symbols)转移到了native heap;字面量(interned strings)转移到了java heap;类的静态变量(class statics)转移到了java heap。</p><p>备注：有OOM异常</p><h3 id="2-6-补充"><a href="#2-6-补充" class="headerlink" title="2.6 补充"></a>2.6 补充</h3><h4 id="2-6-1-运行时常量池和Class文件常量池"><a href="#2-6-1-运行时常量池和Class文件常量池" class="headerlink" title="2.6.1 运行时常量池和Class文件常量池"></a>2.6.1 运行时常量池和Class文件常量池</h4><p>Runtime Constant Pool是方法区的一部分。Class文件中除了有类的版本，字段，方法，接口等描述信息，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性。</p><p>备注：有OOM异常</p><h4 id="2-6-2-直接内存"><a href="#2-6-2-直接内存" class="headerlink" title="2.6.2 直接内存"></a>2.6.2 直接内存</h4><p>Direct Memory，并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。</p><p>在jdk1.4加入的NIO类，引入了一种基于通道（Chanel）与缓冲区（Buffer）的IO方式，<strong>它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。</strong>这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><p>备注：本机直接内存的分配不会受到Java堆大小的限制，受到本机总内存和处理器寻址空间的限制，有OOM异常。</p><h3 id="3-HotSpot虚拟机"><a href="#3-HotSpot虚拟机" class="headerlink" title="3. HotSpot虚拟机"></a>3. HotSpot虚拟机</h3><h4 id="3-1-内存划分"><a href="#3-1-内存划分" class="headerlink" title="3.1 内存划分"></a>3.1 内存划分</h4><p>根据JVM规范，内存可分为：<strong>虚拟机栈，本地方法栈，堆，方法区，程序计数器</strong>五个部分。</p><p>但是各种虚拟机HotSpot，JRockit实现却与JVM不尽相同。</p><p>HotSpot主要有：<strong>虚拟机栈，堆，程序计数器，Metaspace，直接内存</strong>四个部分。</p><p>如下为JDK8的内存划分：</p><p><img src="https://images2018.cnblogs.com/blog/563799/201804/563799-20180424161205943-784876438.png" alt="avatar"></p><p>其中，元空间（Metaspace）的本质和永久代类似，都是对JVM规范中方法区的实现。</p><p>不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。</p><p>因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：</p><p>-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。<br>-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。</p><h3 id="3-2-对象的创建、内存布局、访问定位"><a href="#3-2-对象的创建、内存布局、访问定位" class="headerlink" title="3.2 对象的创建、内存布局、访问定位"></a>3.2 对象的创建、内存布局、访问定位</h3><p>基于虚拟机HotSpot深入探讨Java堆中对象分配、布局和访问的全过程。</p><h4 id="3-2-1-对象的创建"><a href="#3-2-1-对象的创建" class="headerlink" title="3.2.1 对象的创建"></a>3.2.1 对象的创建</h4><p>（1）虚拟机遇到new指令后，首先检查new指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否被加载，解析和初始化过。如果没有，那必须先执行类的加载过程；</p><p>（2）类加载检查通过之后，虚拟机将为新生对象分配内存（<strong>对象所需内存的大小在类加载完成后可完全确定</strong>）；</p><p>（3）内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值；</p><p>（4）对对象进行必要的设置，例如这个对象是哪个类的实例，如果才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄等信息（这些对象存放在对象的对象头Object Header中）</p><p>（5）执行init方法，把对象按照程序员的意愿进行初始化。</p><p>有<strong>指针碰撞和空闲列表</strong>两种分配方式：选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的GC是否带有压缩整理功能决定；因此，在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法时指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。</p><p>此外还有对象创建的并发问题：</p><p>（1）堆分配内存空间的动作进行同步处理–采用CAS配上失败重试的方式保证更新操作的原子性；</p><p>（2）把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓存（Thread Local Allocation Buffer,TLAB）</p><p><strong>注：指针碰撞：内存是规整的，空闲列表：内存不是规整的</strong></p><h4 id="3-2-2-对象的内存布局"><a href="#3-2-2-对象的内存布局" class="headerlink" title="3.2.2 对象的内存布局"></a>3.2.2 对象的内存布局</h4><p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头、实例数据、对齐填充。</p><p>如图：<br><img src="https://images2018.cnblogs.com/blog/563799/201804/563799-20180424165642779-735642794.png" alt="avatar"></p><ol><li>对象头（存储在堆）包括两部分：<br>（1）存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标识，线程持有的锁，偏向线程ID，偏向时间戳等，官方称为Mark Word。Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。</li></ol><p>（2）类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><ol start="2"><li><p>实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。</p></li><li><p>对齐填充并不是必然存在的，也没有特别的含义。HotSpot自动内存管理系统要求对象起始地址必须是8字节的倍数，也就是说对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数，因此，当对象实例数据不符没有对齐时，就需要通过对齐填充来补全。</p></li></ol><h4 id="3-2-3-对象的访问定位"><a href="#3-2-3-对象的访问定位" class="headerlink" title="3.2.3 对象的访问定位"></a>3.2.3 对象的访问定位</h4><p>Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范中规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位，访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而言的。目前主流的访问方式有使用<strong>句柄</strong>和<strong>直接指针</strong>两种。</p><p>（1）句柄访问</p><p>Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。</p><p>（2）直接指针，reference中存储的是对象地址，而对象实例的对象头中有类型指针，指向类型数据。</p><p><img src="https://images2017.cnblogs.com/blog/563799/201710/563799-20171019171310146-817535230.png" alt="avatar"></p><p>两种对象访问各有优势，使用句柄来访问的最大好处是reference中存储的是稳定的句柄地址，对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。</p><p>直接指针最大好处就是速度更快，节省了一次指针定位的时间开销。<br><strong>HotSpot使用了直接指针方式进行对象访问。</strong></p><p>备注：reference应该指向堆中Java对象的内存地址，而对象的内存布局里面包括：对象头和对象数据，对象头里面有对象类型指针。</p><h3 id="4-OOM"><a href="#4-OOM" class="headerlink" title="4. OOM"></a>4. OOM</h3><p>OOM：OutOfMemoryError异常</p><p>在Java虚拟机规范中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OOM异常的可能。</p><p>下面的代码都是基于JDK1.8，因此对<strong>堆，虚拟机栈，Metaspace和直接内存</strong>做验证和分析。</p><h4 id="4-1-堆OOM"><a href="#4-1-堆OOM" class="headerlink" title="4.1 堆OOM"></a>4.1 堆OOM</h4><p>代码:</p><pre><code>import java.util.ArrayList; import java.util.List; /**   * VM -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError   *   */ public class HeapOOM &#123;     public static void main(String[] args) &#123;    List&lt;HeapOOM&gt; list = new ArrayList&lt;HeapOOM&gt;();    while(true)        list.add(new HeapOOM());&#125;&#125; </code></pre><p>-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</p><p>Java堆的大小为20MB，不可扩展；通过参数-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照。</p><p>运行结果：</p><p><img src="https://images2018.cnblogs.com/blog/563799/201804/563799-20180424172145047-1935669708.png" alt="avatar"></p><h4 id="4-2-虚拟机栈OOM"><a href="#4-2-虚拟机栈OOM" class="headerlink" title="4.2 虚拟机栈OOM"></a>4.2 虚拟机栈OOM</h4><p>HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，统一是虚拟机栈。</p><p>栈容量只由-Xss参数设定。</p><p>在Java虚拟机规范中描述了2种异常：</p><p>（1）如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常；</p><p>（2）如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OOM。</p><p>代码:</p><pre><code>/**   * VM -Xss108k   * */  public class JavaVMStackSOF &#123;      private int stackLength = 1;      public void stackLeak() &#123;      stackLength++;      stackLeak();&#125; public static void main(String[] args) &#123;    JavaVMStackSOF oom = new JavaVMStackSOF();    try &#123;        oom.stackLeak();    &#125; catch (Throwable t) &#123;        System.out.println(oom.stackLength);        throw t;    &#125; &#125;&#125;　</code></pre><p>-Xss指定栈内存容量。</p><p>运行结果：</p><p><img src="https://images2018.cnblogs.com/blog/563799/201804/563799-20180424190147259-1583450039.png" alt="avatar"></p><h3 id="4-3-元空间OOM"><a href="#4-3-元空间OOM" class="headerlink" title="4.3 元空间OOM"></a>4.3 元空间OOM</h3><h3 id="4-4-直接内存OOM"><a href="#4-4-直接内存OOM" class="headerlink" title="4.4 直接内存OOM"></a>4.4 直接内存OOM</h3><h3 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5 参考资料"></a>5 参考资料</h3><p>深入理解Java虚拟机：JVM高级特性与最佳实践（第二版）</p><p>　</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载机制</title>
      <link href="2020/06/11/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>2020/06/11/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="1、什么是类的加载"><a href="#1、什么是类的加载" class="headerlink" title="1、什么是类的加载"></a>1、什么是类的加载</h3><p>&emsp;&emsp;类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的<strong>方法区</strong>内，然后在<strong>堆</strong>区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的 Class对象， Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p><p><img src="https://images2015.cnblogs.com/blog/331425/201606/331425-20160621125941772-1913742708.png" alt="avatar"></p><p>&emsp;&emsp;类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误</p><p>####加载.class文件的方式</p><ul><li><p>从本地系统中直接加载</p></li><li><p>通过网络下载.class文件</p></li><li><p>从zip，jar等归档文件中加载.class文件</p></li><li><p>从专有数据库中提取.class文件</p></li><li><p>将Java源文件动态编译为.class文件</p></li></ul><h3 id="2、类的生命周期"><a href="#2、类的生命周期" class="headerlink" title="2、类的生命周期"></a>2、类的生命周期</h3><p><img src="https://images2015.cnblogs.com/blog/331425/201606/331425-20160621125943209-1443333281.png" alt="avatar"></p><p>&emsp;&emsp;其中类加载的过程包括了<font color=#0099ff face="黑体">加载、验证、准备、解析、初始化</font>  五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>&emsp;&emsp;查找并加载类的二进制数据加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p><ol><li><p>通过一个类的全限定名来获取其定义的二进制字节流。</p></li><li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p></li><li><p>在Java堆中生成一个代表这个类的 java.lang.Class对象，作为对方法区中这些数据的访问入口。</p></li></ol><p>&emsp;&emsp;相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><p>&emsp;&emsp;加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。</p><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p><strong>验证：确保被加载的类的正确性</strong></p><p>&emsp;&emsp;验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p><p><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范；例如：是否以 0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</p><p><strong>元数据验证</strong>：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object之外。</p><p><strong>字节码验证</strong>：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p><p><strong>符号引用验证</strong>：确保解析动作能正确执行。</p><p>&emsp;&emsp;验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><p><strong>准备：为类的</strong> 静态变量分<strong>配内存，并将其初始化为默认值</strong></p><p>&emsp;&emsp;准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p><ul><li><p>1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</p></li><li><p>2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</p></li></ul><p>&emsp;&emsp;假设一个类变量的定义为： <code>publicstaticintvalue=3；</code></p><p>&emsp;&emsp;那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的 publicstatic指令是在程序编译后，存放于类构造器 <clinit>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</p><blockquote><p>这里还需要注意如下几点：</p></blockquote><blockquote><ul><li>对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li></ul></blockquote><blockquote><ul><li>对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li></ul></blockquote><blockquote><ul><li>对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。</li></ul></blockquote><blockquote><ul><li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li></ul></blockquote><p>3、如果类字段的字段属性表中存在 <code>ConstantValue</code>属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。</p><p>假设上面的类变量value被定义为： <code>publicstaticfinalintvalue=3；</code></p><p>&emsp;&emsp;编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据 ConstantValue的设置将value赋值为3。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中</p><p><strong>解析：把类中的符号引用转换为直接引用</strong></p><p>&emsp;&emsp;解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p><p>&emsp;&emsp;直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><p><strong>初始化</strong></p><p>&emsp;&emsp;初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p><ul><li><p>①声明类变量是指定初始值</p></li><li><p>②使用静态代码块为类变量指定初始值</p></li></ul><p>JVM初始化步骤</p><ul><li><p>1、假如这个类还没有被加载和连接，则程序先加载并连接该类</p></li><li><p>2、假如该类的直接父类还没有被初始化，则先初始化其直接父类</p></li><li><p>3、假如类中有初始化语句，则系统依次执行这些初始化语句</p></li></ul><p>&emsp;&emsp;类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p><ul><li><p>创建类的实例，也就是new的方式</p></li><li><p>访问某个类或接口的静态变量，或者对该静态变量赋值</p></li><li><p>调用类的静态方法</p></li><li><p>反射（如 Class.forName(“com.shengsiyuan.Test”)）</p></li><li><p>初始化某个类的子类，则其父类也会被初始化</p></li><li><p>Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类</p></li></ul><p><strong>结束生命周期</strong></p><p>&emsp;&emsp;在如下几种情况下，Java虚拟机将结束生命周期</p><ul><li><p>执行了 <code>System.exit()</code>方法</p></li><li><p>程序正常执行结束</p></li><li><p>程序在执行过程中遇到了异常或错误而异常终止</p></li><li><p>由于操作系统出现错误而导致Java虚拟机进程终止</p></li></ul><p><strong>3、类加载器</strong><br>寻找类加载器，先来一个小例子</p><pre><code>``` package com.neo.classloader; public class ClassLoaderTest&#123;   public static void main(String[] args)&#123;      ClassLoader loader = Thread.currentThread().getContextClassLoader();      System.out.printIn(loader);      System.out.printIn(loader.getParent());      System.out.printIn(loader.getParent().getParent());   &#125; &#125;​```</code></pre><p>运行后，输出结果：</p><pre><code>``` sun.misc.Launcher$AppClassLoader@64fef26a sun.misc.Launcher$ExtClassLoader@1ddd40f3 null ```</code></pre><p>&emsp;&emsp;从上面的结果可以看出，并没有获取到 ExtClassLoader的父Loader，原因是 BootstrapLoader（引导类加载器）是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回null。</p><p>&emsp;&emsp;这几种类加载器的层次关系如下图所示：</p><p><img src="https://images2015.cnblogs.com/blog/331425/201606/331425-20160621125944459-1013316302.jpg" alt="avatar"></p><blockquote><p>注意：这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。</p></blockquote><p>&emsp;&emsp;站在Java虚拟机的角度来讲，只存在两种不同的类加载器：启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；所有其它的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类 <code>java.lang.ClassLoader</code>，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p><p>&emsp;&emsp;站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</p><p><strong>启动类加载器：</strong> BootstrapClassLoader，负责加载存放在 JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被 -Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被 BootstrapClassLoader加载）。启动类加载器是无法被Java程序直接引用的。</p><p><strong>扩展类加载器：</strong> ExtensionClassLoader，该加载器由 sun.misc.Launcher$ExtClassLoader实现，它负责加载 JDK\jre\lib\ext目录中，或者由 java.ext.dirs系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。</p><p><strong>应用程序类加载器：</strong> ApplicationClassLoader，该类加载器由 sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><p>&emsp;&emsp;应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p><ul><li><p>1、在执行非置信代码之前，自动验证数字签名。</p></li><li><p>2、动态地创建符合用户特定需要的定制化构建类。</p></li><li><p>3、从特定的场所取得java class，例如数据库中和网络中。</p></li></ul><p>JVM类加载机制</p><ul><li><p><strong>全盘负责</strong>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p></li><li><p><strong>父类委托</strong>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p></li><li><p><strong>缓存机制</strong>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p></li></ul><p><strong>4、类的加载</strong><br>类加载有三种方式：</p><p>1、命令行启动应用时候由JVM初始化加载</p><p>2、通过Class.forName()方法动态加载</p><p>3、通过ClassLoader.loadClass()方法动态加载</p><p><strong>Class.forName()和ClassLoader.loadClass()区别</strong></p><ul><li><p><code>Class.forName()</code>：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</p></li><li><p><code>ClassLoader.loadClass()</code>：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</p></li><li><p><code>Class.forName(name,initialize,loader)</code>带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。</p></li></ul><p><strong>5、双亲委派模型</strong></p><p>&emsp;&emsp;双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p><p>双亲委派机制:</p><p>1、当 <code>AppClassLoader</code>加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</p><p>2、当 <code>ExtClassLoader</code>加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader```去完成。</p><p>3、如果 <code>BootStrapClassLoader</code>加载失败（例如在 <code>$JAVA_HOME/jre/lib</code>里未查找到该class），会使用 ExtClassLoader来尝试加载；</p><p>4、若ExtClassLoader也加载失败，则会使用 <code>AppClassLoader</code>来加载，如果 <code>AppClassLoader</code>也加载失败，则会报出异常 <code>ClassNotFoundException</code>。</p><p>双亲委派模型意义：</p><ul><li><p>系统类防止内存中出现多份同样的字节码</p></li><li><p>保证Java程序安全稳定运行</p></li></ul><p><strong>6、自定义类加载器</strong></p><p>&emsp;&emsp;通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自 ClassLoader类，从上面对 loadClass方法来分析来看，我们只需要重写 findClass 方法即可。</p><p>&emsp;&emsp;自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，我并未对class文件进行加密，因此没有解密的过程。这里有几点需要注意：</p><ul><li><p>1、这里传递的文件名需要是类的全限定性名称，即 <code>com.paddx.test.classloading.Test</code>格式的，因为 defineClass 方法是按这种格式进行处理的。</p></li><li><p>2、最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。</p></li><li><p>3、这类Test 类本身可以被 <code>AppClassLoader</code>类加载，因此我们不能把 <code>com/paddx/test/classloading/Test.class</code>放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由 AppClassLoader加载，而不会通过我们自定义类加载器来加载。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

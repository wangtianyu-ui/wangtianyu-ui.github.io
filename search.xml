<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Voliate关键字</title>
      <link href="2020/10/01/Voliate%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>2020/10/01/Voliate%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h3 id="voliate关键字"><a href="#voliate关键字" class="headerlink" title="voliate关键字"></a>voliate关键字</h3><p>####1 使变量在线程间可见<br>对于避免不可见性问题，Java还提供了一种弱形式的同步，即使用了volatile关键字。该关键字确保了对一个变量的更新对其他线程可见。当一个变量被声明为volatile时候，线程写入时候不会把值缓存在寄存器或者或者在其他地方，当线程读取的时候会从主内存重新获取最新值，而不是使用当前线程的拷贝内存变量值。volatile虽然提供了可见性保证，但是不能使用他来构建复合的原子性操作，也就是说当一个变量依赖其他变量或者更新变量值时候新值依赖当前老值时候不在适用。与synchronized相似之处在于如图</p><p><img src="https://upload-images.jianshu.io/upload_images/1463524-341008d65746e274.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="avatar"></p><p>如图线程A修改了volatile变量b的值，然后线程B读取了改变量值，那么所有A线程在写入变量b值前可见的变量值，在B读取volatile变量b后对线程B都是可见的，图中线程B对A操作的变量a,b的值都可见的。volatile的内存语义和synchronized有类似之处，具体说是说当线程写入了volatile变量值就等价于线程退出synchronized同步块（会把写入到本地内存的变量值同步到主内存），读取volatile变量值就相当于进入同步块（会先清空本地内存变量值，从主内存获取最新值）。</p><pre><code>```java public class Test extends Thread&#123; //voliateprivate String i =&quot;sss&quot;;private void setI(String i)&#123;    this.i=i;&#125;@Overridepublic void run() &#123;    System.out.println(&quot;进入方法&quot;+i);    while (i.equals(&quot;sss&quot;))&#123;    &#125;    System.out.println(&quot;线程结束&quot;);&#125;public static void main(String[] args ) throws InterruptedException&#123;    Test test=new Test();    test.start();    Thread.sleep(1000);    System.out.println(&quot;线程设置了stop&quot;);    test.setI(&quot;线程设置了stop&quot;); &#125;&#125;```</code></pre><p>上面是一个简单的示例。</p><ol><li>首先运行代码,可以看到,尽管将变量设置了stop,test线程并没有如预期的停止.说明,test线程内的i的并没有被修改,test只是在start时将i变量拷贝到了线程自有的一块空间内,与主线内的i变量互不影响.</li></ol><p>2.将voliate关键字放在变量i的声明上,运行发现程序正常停止.可见变量i在任何一个线程内都是可见的,当变量i在主线程被修改时,子线程立即获得了被更新的值.</p><ol start="3"><li>最坑的地方来了,打开代码中的while循环中的打印语句,将voliate关键字注释掉,执行代码.神奇的事情发生了,程序正常的停止了,WTF!(在我最开始研究voliate的时候,我一直有这句输出语句,一直得不到正确结果)这是为啥呢？下面这段话基本说明了问题,同时你也可以将输出语句注释点,打开sleep的注释,看看结果.</li></ol><p>JVM会尽力保证内存的可见性，即便这个变量没有加同步关键字。换句话说，只要CPU有时间，JVM会尽力去保证变量值的更新。这种与volatile关键字的不同在于，volatile关键字会强制的保证线程的可见性。而不加这个关键字，JVM也会尽力去保证可见性，但是如果CPU一直有其他的事情在处理，它也没办法。最开始的代码，一直处于试了循环中，CPU处于一直被饱受占用的时候，这个时候CPU没有时间，JVM也不能强制要求CPU分点时间去取最新的变量值。而加了System.out.println之后，由于内部代码的同步关键字的存在，导致CPU的输出其实是比较耗时的。这个时候CPU就有可能有时间去保证内存的可见性，于是while循环可以被终止。其实，也可以在while循环里面加上sleep，让run方法放弃cpu，但是不放弃锁，这个时候由于CPU有空闲的时候就去按照JVM的要求去保证内存的可见性。如下图所示。 run方法里面休息了3秒，cpu有充足的空闲时间去取变量的最新值，所以循环执行一次就停止了。</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是AQS及其原理</title>
      <link href="2020/09/12/AQS%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/"/>
      <url>2020/09/12/AQS%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="1、AQS简介"><a href="#1、AQS简介" class="headerlink" title="1、AQS简介"></a>1、AQS简介</h3><p>AQS全名：AbstractQueuedSynchronizer，是并发容器J.U.C（java.lang.concurrent）下locks包内的一个类。它实现了一个FIFO(FirstIn、FisrtOut先进先出)的队列。底层实现的数据结构是一个双向链表。</p><p><img src="https://www.pianshen.com/images/796/7cc7646e4fd1cb94f1cbf6e895725b94.png" alt="avatar"></p><p>Sync queue：同步队列，是一个双向链表。包括head节点和tail节点。head节点主要用作后续的调度。 Condition queue：非必须，单向链表。当程序中存在cindition的时候才会存在此列表。</p><p><strong>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p><p><strong>AQS使用一个int成员变量来表示同步状态</strong>，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。</p><p>状态信息通过procted类型的getState，setState，compareAndSetState进行操作</p><pre><code>```//返回同步状态的当前值 protected final int getState() &#123;       return state; &#125; // 设置同步状态的值 protected final void setState(int newState) &#123;      state = newState;&#125;//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）protected final boolean compareAndSetState(int expect, int update) &#123;   return unsafe.compareAndSwapInt(this, stateOffset, expect, update);&#125;```</code></pre><h3 id="2、AQS设计思想"><a href="#2、AQS设计思想" class="headerlink" title="2、AQS设计思想"></a>2、AQS设计思想</h3><ul><li>使用Node实现FIFO队列，可以用于构建锁或者其他同步装置的基础框架。</li><li>利用int类型标识状态。<strong>在AQS类中有一个叫做state的成员变量</strong></li></ul><p>基于AQS有一个同步组件，叫做ReentrantLock。<strong>在这个组件里，stste表示获取锁的线程数，假如state=0，表示还没有线程获取锁，1表示有线程获取了锁。大于1表示重入锁的数量。</strong></p><p>继承：子类通过继承并通过实现它的方法管理其状态（acquire和release方法操纵状态）。</p><p>可以同时实现排它锁和共享锁模式（独占、共享），站在一个使用者的角度，AQS的功能主要分为两类：<strong>独占和共享</strong>。它的所有子类中，要么实现并使用了它的独占功能的api，要么使用了共享锁的功能，而不会同时使用两套api，即便是最有名的子类ReentrantReadWriteLock也是通过两个内部类读锁和写锁分别实现了两套api来实现的。</p><h3 id="3、AQS的大致实现思路"><a href="#3、AQS的大致实现思路" class="headerlink" title="3、AQS的大致实现思路"></a>3、AQS的大致实现思路</h3><p>AQS内部维护了一个CLH队列来管理锁。<strong>线程会首先尝试获取锁，如果失败就将当前线程及等待状态等信息包装成一个node节点加入到同步队列sync queue里</strong>。 接着会不断的循环尝试获取锁，条件是当前节点为head的直接后继才会尝试。如果失败就会阻塞自己直到自己被唤醒。而当持有锁的线程释放锁的时候，会唤醒队列中的后继线程。</p><p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中CAS详解</title>
      <link href="2020/09/01/Java%E4%B8%ADCAS%E8%AF%A6%E8%A7%A3/"/>
      <url>2020/09/01/Java%E4%B8%ADCAS%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>在JDK 5之前Java语言是靠synchronized关键字保证同步的，这会导致有锁</p><p>锁机制存在以下问题：</p><p>（1）在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</p><p>（2）一个线程持有锁会导致其它所有需要此锁的线程挂起。</p><p>（3）如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。</p><p>volatile是不错的机制，但是volatile不能保证原子性。因此对于同步最终还是要回到锁机制上来。</p><p><strong>独占锁是一种悲观锁，synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁用到的机制就是CAS，Compare and Swap。</strong></p><h3 id="一、什么是CAS"><a href="#一、什么是CAS" class="headerlink" title="一、什么是CAS"></a>一、什么是CAS</h3><p>CAS,compare and swap的缩写，中文翻译成比较并交换。</p><p>我们都知道，在java语言之前，并发就已经广泛存在并在服务器领域得到了大量的应用。所以硬件厂商老早就在芯片中加入了大量直至并发操作的原语，从而在硬件层面提升效率。在intel的CPU中，使用cmpxchg指令。</p><p>在Java发展初期，java语言是不能够利用硬件提供的这些便利来提升系统的性能的。而随着java不断的发展,Java本地方法(JNI)的出现，使得java程序越过JVM直接调用本地方法提供了一种便捷的方式，因而java在并发的手段上也多了起来。而在Doug Lea提供的cucurenct包中，CAS理论是它实现整个java包的基石。</p><p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该 位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”</p><p>通常将 CAS 用于同步的方式是从地址 V 读取值 A，执行多步计算来获得新 值 B，然后使用 CAS 将 V 的值从 A 改为 B。如果 V 处的值尚未同时更改，则 CAS 操作成功。</p><p>类似于 CAS 的指令允许算法执行读-修改-写操作，而无需害怕其他线程同时 修改变量，因为如果其他线程修改变量，那么 CAS 会检测它（并失败），算法 可以对该操作重新计算。</p><h3 id="二、CAS的目的"><a href="#二、CAS的目的" class="headerlink" title="二、CAS的目的"></a>二、CAS的目的</h3><p>利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法。其它原子操作都是利用类似的特性完成的。而整个J.U.C都是建立在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很大的提升。</p><p>三、CAS存在的问题</p><p>CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作</p><p><strong>1.  ABA问题</strong>。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。</p><p>从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><p>**<br>2. 循环时间长开销大**。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p><p><strong>3. 只能保证一个共享变量的原子操作</strong>。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</p><h3 id="四、concurrent包的实现"><a href="#四、concurrent包的实现" class="headerlink" title="四、concurrent包的实现"></a>四、concurrent包的实现</h3><p>由于java的CAS同时具有 volatile 读和volatile写的内存语义，因此Java线程之间的通信现在有了下面四种方式：</p><p>A线程写volatile变量，随后B线程读这个volatile变量。<br>A线程写volatile变量，随后B线程用CAS更新这个volatile变量。<br>A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。<br>A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。<br>Java的CAS会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键（从本质上来说，能够支持原子性读-改-写指令的计算机器，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）。同时，volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式：</p><p>首先，声明共享变量为volatile；<br>然后，使用CAS的原子条件更新来实现线程之间的同步；<br>同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。<br>AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程池详解</title>
      <link href="2020/08/20/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/"/>
      <url>2020/08/20/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>###1、线程池的优势</p><p>（1）、降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；<br>（2）、提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；<br>（3）方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换（cpu切换线程是有时间成本的（需要保持当前执行线程的现场，并恢复要执行线程的现场））。<br>（4）提供更强大的功能，延时定时线程池。</p><h3 id="2、线程池的主要参数"><a href="#2、线程池的主要参数" class="headerlink" title="2、线程池的主要参数"></a>2、线程池的主要参数</h3><pre><code>``` public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123;this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,     Executors.defaultThreadFactory(), defaultHandler);&#125;```</code></pre><p>1、corePoolSize（线程池基本大小）：当向线程池提交一个任务时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于corePoolSize时，（除了利用提交新任务来创建和启动线程（按需构造），也可以通过 prestartCoreThread() 或 prestartAllCoreThreads() 方法来提前启动线程池中的基本线程。）</p><p>2、maximumPoolSize（线程池最大大小）：线程池所允许的最大线程个数。当队列满了，且已创建的线程数小于maximumPoolSize，则线程池会创建新的线程来执行任务。另外，对于无界队列，可忽略该参数。</p><p>3、keepAliveTime（线程存活保持时间）当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。</p><p>4、workQueue（任务队列）：用于传输和保存等待执行任务的阻塞队列。</p><p>5、threadFactory（线程工厂）：用于创建新线程。threadFactory创建的线程也是采用new Thread()方式，threadFactory创建的线程名都具有统一的风格：pool-m-thread-n（m为线程池的编号，n为线程池内的线程编号）。</p><p>5、handler（线程饱和策略）：当线程池和队列都满了，再加入线程会执行此策略。</p><h3 id="3、线程池流程"><a href="#3、线程池流程" class="headerlink" title="3、线程池流程"></a>3、线程池流程</h3><p><img src="https://upload-images.jianshu.io/upload_images/6024478-88ee7b20f8f45825.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/937/format/webp" alt="avatar"></p><p>1、判断核心线程池是否已满，没满则创建一个新的工作线程来执行任务。已满则。<br>2、判断任务队列是否已满，没满则将新提交的任务添加在工作队列，已满则。<br>3、判断整个线程池是否已满，没满则创建一个新的工作线程来执行任务，已满则执行饱和策略。</p><p>（1、判断线程池中当前线程数是否大于核心线程数，如果小于，在创建一个新的线程来执行任务，如果大于则<br>2、判断任务队列是否已满，没满则将新提交的任务添加在工作队列，已满则。<br>3、判断线程池中当前线程数是否大于最大线程数，如果小于，则创建一个新的线程来执行任务，如果大于，则执行饱和策略。）</p><h3 id="4、线程池为什么需要使用（阻塞）队列？"><a href="#4、线程池为什么需要使用（阻塞）队列？" class="headerlink" title="4、线程池为什么需要使用（阻塞）队列？"></a>4、线程池为什么需要使用（阻塞）队列？</h3><p>回到了非线程池缺点中的第3点：<br>1、因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换。</p><p>另外回到了非线程池缺点中的第1点：<br>2、创建线程池的消耗较高。<br>或者下面这个网上并不高明的回答：<br>2、线程池创建线程需要获取mainlock这个全局锁，影响并发效率，阻塞队列可以很好的缓冲。</p><h3 id="5、线程池为什么要使用阻塞队列而不使用非阻塞队列？"><a href="#5、线程池为什么要使用阻塞队列而不使用非阻塞队列？" class="headerlink" title="5、线程池为什么要使用阻塞队列而不使用非阻塞队列？"></a>5、线程池为什么要使用阻塞队列而不使用非阻塞队列？</h3><p>阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使得线程进入wait状态，释放cpu资源。<br>当队列中有任务时才唤醒对应线程从队列中取出消息进行执行。<br>使得在线程不至于一直占用cpu资源。</p><p>（线程执行完任务后通过循环再次从任务队列中取出任务进行执行，代码片段如下<br>while (task != null || (task = getTask()) != null) {}）。</p><p>不用阻塞队列也是可以的，不过实现起来比较麻烦而已，有好用的为啥不用呢？</p><h3 id="6-如何配置线程池"><a href="#6-如何配置线程池" class="headerlink" title="6.如何配置线程池"></a>6.如何配置线程池</h3><p>CPU密集型任务<br>尽量使用较小的线程池，一般为CPU核心数+1。 因为CPU密集型任务使得CPU使用率很高，若开过多的线程数，会造成CPU过度切换。</p><p>IO密集型任务<br>可以使用稍大的线程池，一般为2*CPU核心数。 IO密集型任务CPU使用率并不高，因此可以让CPU在等待IO的时候有其他线程去处理别的任务，充分利用CPU时间。</p><p>混合型任务<br>可以将任务分成IO密集型和CPU密集型任务，然后分别用不同的线程池去处理。 只要分完之后两个任务的执行时间相差不大，那么就会比串行执行来的高效。<br>因为如果划分之后两个任务执行时间有数据级的差距，那么拆分没有意义。<br>因为先执行完的任务就要等后执行完的任务，最终的时间仍然取决于后执行完的任务，而且还要加上任务拆分与合并的开销，得不偿失。</p><h3 id="7、java中提供的线程池"><a href="#7、java中提供的线程池" class="headerlink" title="7、java中提供的线程池"></a>7、java中提供的线程池</h3><p>Executors类提供了4种不同的线程池：newCachedThreadPool, newFixedThreadPool, newScheduledThreadPool, newSingleThreadExecutor</p><p>1、newCachedThreadPool：用来创建一个可以无限扩大的线程池，适用于负载较轻的场景，执行短期异步任务。（可以使得任务快速得到执行，因为任务时间执行短，可以很快结束，也不会造成cpu过度切换）</p><p>2、newFixedThreadPool：创建一个固定大小的线程池，因为采用无界的阻塞队列，所以实际线程数量永远不会变化，适用于负载较重的场景，对当前线程数量进行限制。（保证线程数可控，不会造成线程过多，导致系统负载更为严重）</p><p>3、newSingleThreadExecutor：创建一个单线程的线程池，适用于需要保证顺序执行各个任务。</p><p>4、newScheduledThreadPool：适用于执行延时或者周期性任务。</p><h3 id="8、execute-和submit-方法"><a href="#8、execute-和submit-方法" class="headerlink" title="8、execute()和submit()方法"></a>8、execute()和submit()方法</h3><p>1、execute()，执行一个任务，没有返回值。<br>2、submit()，提交一个线程任务，有返回值。<br>submit(Callable<T> task)能获取到它的返回值，通过future.get()获取（阻塞直到任务执行完）。一般使用FutureTask+Callable配合使用（IntentService中有体现）。</p><p>submit(Runnable task, T result)能通过传入的载体result间接获得线程的返回值。<br>submit(Runnable task)则是没有返回值的，就算获取它的返回值也是null。</p><p>Future.get方法会使取结果的线程进入阻塞状态，知道线程执行完成之后，唤醒取结果的线程，然后返回结果。</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程的挑战</title>
      <link href="2020/08/15/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8C%91%E6%88%98/"/>
      <url>2020/08/15/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8C%91%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p>1、上下文切换的问题</p><p>2、死锁的问题、</p><p>3、受限于硬件和软件的资源问题</p><p>一、上下文切换问题</p><p>单核处理器也支持多线程执行代码，cpu通过给每个线程分配cpu时间片来实现这个机制，时间片非常短，需要不停的切换线程执行，让我们感觉多线程是同时执行的，时间片一般是几十毫秒</p><p>查看上下文切换状态：</p><blockquote><p>**grep java.lang.Thread.State dump305 | awk ‘{print $2$3$4$5}’ | sort | uniq -c  **</p></blockquote><p>任务从保存到再加载的过程就是一次上下文切换，上下文切换会影响多线程的执行速度</p><p>如何减少上下文切换？</p><p>1、无锁并发编程</p><p>可以用一些方法来避免使用锁，如将数据的ID按照哈希算法取模分段，不同的线程处理不同段的数据</p><p>2、CAS算法</p><p>3、使用最少线程和使用协程</p><p>在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换</p><p>避免死锁的几个常见方法</p><p>1、避免一个线程同时获取多个锁</p><p>2、避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源</p><p>3、尝试使用定时锁，使用lock.tryLcok(timeout)来替代使用内部锁机制</p><p>4、对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况</p><p>资源限制</p><p>硬件资源限制：带宽的上传下载速度、硬盘的读写速度、CPU的处理速度、</p><p>解决方案：可以使用集群并行执行程序</p><p>软件资源限制：数据库的连接数、socket的连接数</p><p>解决方案：可以使用资源池将资源复用，如数据库的连接池和Socket复用，或者在调用对方的webservice接口的时候，只建立一个连接</p><p>在资源限制的情况下进行并发编程</p><p>根据不同的资源，限制调整程序的并发度，如下载文件程序依赖于带宽和磁盘读写速度，有数据库操作时候，涉及到数据库的连接数，如果sql执行非常快，而线程的数量比数据库连接数大很多，则某些线程会被阻塞，等待数据库的连接。</p><p>CPU飙升到100%，有可能是不恰当的并发程序引起的</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发机制的底层实现原理</title>
      <link href="2020/08/01/Java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>2020/08/01/Java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>java中所使用的并发机制依赖于jvm的实现和cpu的指令</p><p>volatile</p><p>volatile是轻量级的synchronized，如果这个修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为他不会引起线程上下文的切换和调度</p><p>定义：java允许线程访问共享变量，为了确保共享变量能被准确和一致性的更新，线程应该确保通过排他锁单独获得这个变量，如果一个字段被设置成volatile，java线程内存模型确保所以线程看到的这个变量的值是一致的</p><p>lock前缀的指令在多核处理器下会做两件事：</p><p>1）将当前处理器缓存行的数据写回到系统内存</p><p>2）这个写回内存的操作会使在其他cpu里面缓存了该内存地址的数据无效</p><p>当使用volatile修饰的变量进行写操作的时候，jvm就会向处理器发送一条lock前缀的指令，通过缓存一致性协议，每个处理器嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读取到缓存里</p><p>volatile的两条实现规则</p><p>（1）lock前缀指令会引起处理器缓存回写到内存</p><p>（2）一个处理器的缓存回写到内存会导致其他的处理器的缓存无效</p><p>volatile的优化</p><p>LinkedTransferQueue通过追加成64字节的方式提高效率，因为很多处理器的高速缓存行都是64字节，如果不追加空的字节会把头节点和尾节点放到一个缓存行，导致修改的时候缓存锁定，入队和出队不能同时操作而相互锁定</p><p>以下两种场景不应该把volatile变量追加到64字节</p><p>1）缓存行非64字节的处理器</p><p>2）共享变量不会被频繁的写</p><p>这种追加字节的方式在java7中不可能生效，因为会淘汰或者重新排序无用的字段，需要使用其他追加字节的方式</p><p>synchronized</p><p>对于普通的同步方法 锁的是当前实例的对象</p><p>对于静态的同步方法锁的是当前类的class对象</p><p>对于同步代码块 锁的是括号里的对象</p><p>jvm基于进入和退出Monitor对象来实现方法同步和代码块同步</p><p>synchronized用的锁是存在于java对象头里面的，如果对象是数组类型，则虚拟机用三个字宽存储对象头，如果对象是非数组类型，则使用2个字宽存储对象头，在32位的虚拟机中，一字宽是32bit，即4字节</p><p><img src="https://img-blog.csdnimg.cn/20191029180701482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbjg4ODg4ODg4ODg4ODg4ODg4,size_16,color_FFFFFF,t_70" alt="avatar"></p><p>Mark Word 默认存储对象的hashcode，分代年龄和锁标记位，32位的jvm的 Mark Word 默认存储如下所示</p><p><img src="https://img-blog.csdnimg.cn/20191029180914348.png" alt="avatar"></p><p>Mark Word里面的数据会随着运行而变化，可能有以下四种情况<br><img src="https://img-blog.csdnimg.cn/2019102918132359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbjg4ODg4ODg4ODg4ODg4ODg4,size_16,color_FFFFFF,t_70" alt="avatar"></p><p> 64位的存储结构</p><p><img src="https://img-blog.csdnimg.cn/20191029183211209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbjg4ODg4ODg4ODg4ODg4ODg4,size_16,color_FFFFFF,t_70" alt="avatar"></p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存划分</title>
      <link href="2020/07/12/JVM%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/"/>
      <url>2020/07/12/JVM%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>###1. 概述<br>对于Java程序员，在虚拟机自动内存管理机制的帮助下，不再需要为每个new操作去写配对的delete/free代码，不容易出现内存泄漏和内存溢出问题。</p><h3 id="2-运行时数据区域"><a href="#2-运行时数据区域" class="headerlink" title="2. 运行时数据区域"></a>2. 运行时数据区域</h3><p>Java虚拟机在执行Java程序的过程中会把它管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范（Java SE 7版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域：程序计数器，Java虚拟机栈，本地方法栈，Java堆，方法区。</p><p>下图为各个区域以及进一步细化图：</p><p><img src="https://images2018.cnblogs.com/blog/563799/201804/563799-20180424161205943-784876438.png" alt="avatar"></p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p><strong>程序计数器（Program Counter Register）是一块较小的内存空间，可以看做当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</strong></p><p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，每个线程之间计数器互不影响，独立存储。</p><p>备注：</p><p>（a）如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器的值则为空。</p><p>（b）此内存区域是唯一在Java虚拟机规范中没有规定任何OOM情况的区域。</p><h4 id="2-2-Java虚拟机栈"><a href="#2-2-Java虚拟机栈" class="headerlink" title="2.2 Java虚拟机栈"></a>2.2 Java虚拟机栈</h4><p>Java Virtual Machine Stacks，也是线程私有的，它的生命周期与线程相同。</p><p>虚拟机栈描述的是<strong>Java方法执行的内存模型（非native方法）</strong>。</p><p>每个方法在执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。</p><p>每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程，当方法被调用则入栈，一旦完成调用则出栈。所有的栈帧都出栈后，线程就结束了。</p><p>局部变量表存放了编译器可知的各种<strong>基本数据类型、对象引用、returnAddress类型</strong>。局部变量表所需的内存空间在编译器完成分配。当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><p><strong>基本类型</strong>：boolean, byte, char, short, int, float, long, double，其中long和double占用2个局部变量空间slot其余的占用1个；</p><p><strong>对象引用</strong>：reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置；</p><p><strong>returnAddress类型</strong>：指向了一条字节码指令的地址；</p><p>在Java虚拟机规范中，对这个区域规定了两种异常：线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（目前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，抛出OutOfMemoryError异常。</p><h4 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3 本地方法栈"></a>2.3 本地方法栈</h4><p>Native Method Stack与虚拟机栈的作用非常相似，区别是：虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法。</p><p>备注：HotSpot直接把本地方法栈和虚拟机栈合二为一。本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p><h4 id="2-4-Java堆"><a href="#2-4-Java堆" class="headerlink" title="2.4 Java堆"></a>2.4 Java堆</h4><p>Java Heap是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此区域的唯一目的就是存放对象实例（Java虚拟机规范中的描述时：所有的对象实例以及数组都要在堆上分配）。</p><p>Java堆是GC的主要区域，因此很多时候也被称为GC堆。</p><p><strong>从内存分配的角度来看</strong>，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer, TLAB）</p><p><strong>从内存回收的角度来看</strong>，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代，在细致一点的有Eden空间，From Survivor空间，To Survivor空间等。</p><p>备注：有OOM异常</p><h4 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h4><p><strong>Method Area是各个线程共享内存区域，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。</strong></p><p>在HtoSpot虚拟机中该区域叫永久代，即方法区是虚拟机规范，而永久代是HotSpot实现的方法区。</p><p>绝大部分Java 程序员应该都见过 “java.lang.OutOfMemoryError: PermGen space “这个异常。这里的 “PermGen space”其实指的就是方法区（永久代）。不过方法区和“PermGen space”又有着本质的区别。前者是 JVM 的规范，而后者则是JVM 规范的一种实现，并且只有 HotSpot 才有 “PermGen space”，而对于其他类型的虚拟机，如JRockit（Oracle）、J9（IBM）并没有“PermGen space”。</p><p>注：从JDK7开始永久代的移除工作，存储在永久代的一部分数据已经转移到了Java Heap或者是Native Heap。但永久代仍然存在于JDK7，并没有完全的移除：符号引用(Symbols)转移到了native heap;字面量(interned strings)转移到了java heap;类的静态变量(class statics)转移到了java heap。</p><p>备注：有OOM异常</p><h3 id="2-6-补充"><a href="#2-6-补充" class="headerlink" title="2.6 补充"></a>2.6 补充</h3><h4 id="2-6-1-运行时常量池和Class文件常量池"><a href="#2-6-1-运行时常量池和Class文件常量池" class="headerlink" title="2.6.1 运行时常量池和Class文件常量池"></a>2.6.1 运行时常量池和Class文件常量池</h4><p>Runtime Constant Pool是方法区的一部分。Class文件中除了有类的版本，字段，方法，接口等描述信息，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性。</p><p>备注：有OOM异常</p><h4 id="2-6-2-直接内存"><a href="#2-6-2-直接内存" class="headerlink" title="2.6.2 直接内存"></a>2.6.2 直接内存</h4><p>Direct Memory，并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。</p><p>在jdk1.4加入的NIO类，引入了一种基于通道（Chanel）与缓冲区（Buffer）的IO方式，<strong>它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。</strong>这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><p>备注：本机直接内存的分配不会受到Java堆大小的限制，受到本机总内存和处理器寻址空间的限制，有OOM异常。</p><h3 id="3-HotSpot虚拟机"><a href="#3-HotSpot虚拟机" class="headerlink" title="3. HotSpot虚拟机"></a>3. HotSpot虚拟机</h3><h4 id="3-1-内存划分"><a href="#3-1-内存划分" class="headerlink" title="3.1 内存划分"></a>3.1 内存划分</h4><p>根据JVM规范，内存可分为：<strong>虚拟机栈，本地方法栈，堆，方法区，程序计数器</strong>五个部分。</p><p>但是各种虚拟机HotSpot，JRockit实现却与JVM不尽相同。</p><p>HotSpot主要有：<strong>虚拟机栈，堆，程序计数器，Metaspace，直接内存</strong>四个部分。</p><p>如下为JDK8的内存划分：</p><p><img src="https://images2018.cnblogs.com/blog/563799/201804/563799-20180424161205943-784876438.png" alt="avatar"></p><p>其中，元空间（Metaspace）的本质和永久代类似，都是对JVM规范中方法区的实现。</p><p>不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。</p><p>因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：</p><p>-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。<br>-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。</p><h3 id="3-2-对象的创建、内存布局、访问定位"><a href="#3-2-对象的创建、内存布局、访问定位" class="headerlink" title="3.2 对象的创建、内存布局、访问定位"></a>3.2 对象的创建、内存布局、访问定位</h3><p>基于虚拟机HotSpot深入探讨Java堆中对象分配、布局和访问的全过程。</p><h4 id="3-2-1-对象的创建"><a href="#3-2-1-对象的创建" class="headerlink" title="3.2.1 对象的创建"></a>3.2.1 对象的创建</h4><p>（1）虚拟机遇到new指令后，首先检查new指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否被加载，解析和初始化过。如果没有，那必须先执行类的加载过程；</p><p>（2）类加载检查通过之后，虚拟机将为新生对象分配内存（<strong>对象所需内存的大小在类加载完成后可完全确定</strong>）；</p><p>（3）内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值；</p><p>（4）对对象进行必要的设置，例如这个对象是哪个类的实例，如果才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄等信息（这些对象存放在对象的对象头Object Header中）</p><p>（5）执行init方法，把对象按照程序员的意愿进行初始化。</p><p>有<strong>指针碰撞和空闲列表</strong>两种分配方式：选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的GC是否带有压缩整理功能决定；因此，在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法时指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。</p><p>此外还有对象创建的并发问题：</p><p>（1）堆分配内存空间的动作进行同步处理–采用CAS配上失败重试的方式保证更新操作的原子性；</p><p>（2）把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓存（Thread Local Allocation Buffer,TLAB）</p><p><strong>注：指针碰撞：内存是规整的，空闲列表：内存不是规整的</strong></p><h4 id="3-2-2-对象的内存布局"><a href="#3-2-2-对象的内存布局" class="headerlink" title="3.2.2 对象的内存布局"></a>3.2.2 对象的内存布局</h4><p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头、实例数据、对齐填充。</p><p>如图：<br><img src="https://images2018.cnblogs.com/blog/563799/201804/563799-20180424165642779-735642794.png" alt="avatar"></p><ol><li>对象头（存储在堆）包括两部分：<br>（1）存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标识，线程持有的锁，偏向线程ID，偏向时间戳等，官方称为Mark Word。Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。</li></ol><p>（2）类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><ol start="2"><li><p>实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。</p></li><li><p>对齐填充并不是必然存在的，也没有特别的含义。HotSpot自动内存管理系统要求对象起始地址必须是8字节的倍数，也就是说对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数，因此，当对象实例数据不符没有对齐时，就需要通过对齐填充来补全。</p></li></ol><h4 id="3-2-3-对象的访问定位"><a href="#3-2-3-对象的访问定位" class="headerlink" title="3.2.3 对象的访问定位"></a>3.2.3 对象的访问定位</h4><p>Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范中规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位，访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而言的。目前主流的访问方式有使用<strong>句柄</strong>和<strong>直接指针</strong>两种。</p><p>（1）句柄访问</p><p>Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。</p><p>（2）直接指针，reference中存储的是对象地址，而对象实例的对象头中有类型指针，指向类型数据。</p><p><img src="https://images2017.cnblogs.com/blog/563799/201710/563799-20171019171310146-817535230.png" alt="avatar"></p><p>两种对象访问各有优势，使用句柄来访问的最大好处是reference中存储的是稳定的句柄地址，对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。</p><p>直接指针最大好处就是速度更快，节省了一次指针定位的时间开销。<br><strong>HotSpot使用了直接指针方式进行对象访问。</strong></p><p>备注：reference应该指向堆中Java对象的内存地址，而对象的内存布局里面包括：对象头和对象数据，对象头里面有对象类型指针。</p><h3 id="4-OOM"><a href="#4-OOM" class="headerlink" title="4. OOM"></a>4. OOM</h3><p>OOM：OutOfMemoryError异常</p><p>在Java虚拟机规范中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OOM异常的可能。</p><p>下面的代码都是基于JDK1.8，因此对<strong>堆，虚拟机栈，Metaspace和直接内存</strong>做验证和分析。</p><h4 id="4-1-堆OOM"><a href="#4-1-堆OOM" class="headerlink" title="4.1 堆OOM"></a>4.1 堆OOM</h4><p>代码:</p><pre><code>import java.util.ArrayList; import java.util.List; /**   * VM -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError   *   */ public class HeapOOM &#123;     public static void main(String[] args) &#123;    List&lt;HeapOOM&gt; list = new ArrayList&lt;HeapOOM&gt;();    while(true)        list.add(new HeapOOM());&#125;&#125; </code></pre><p>-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</p><p>Java堆的大小为20MB，不可扩展；通过参数-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照。</p><p>运行结果：</p><p><img src="https://images2018.cnblogs.com/blog/563799/201804/563799-20180424172145047-1935669708.png" alt="avatar"></p><h4 id="4-2-虚拟机栈OOM"><a href="#4-2-虚拟机栈OOM" class="headerlink" title="4.2 虚拟机栈OOM"></a>4.2 虚拟机栈OOM</h4><p>HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，统一是虚拟机栈。</p><p>栈容量只由-Xss参数设定。</p><p>在Java虚拟机规范中描述了2种异常：</p><p>（1）如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常；</p><p>（2）如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OOM。</p><p>代码:</p><pre><code>/**   * VM -Xss108k   * */  public class JavaVMStackSOF &#123;      private int stackLength = 1;      public void stackLeak() &#123;      stackLength++;      stackLeak();&#125; public static void main(String[] args) &#123;    JavaVMStackSOF oom = new JavaVMStackSOF();    try &#123;        oom.stackLeak();    &#125; catch (Throwable t) &#123;        System.out.println(oom.stackLength);        throw t;    &#125; &#125;&#125;　</code></pre><p>-Xss指定栈内存容量。</p><p>运行结果：</p><p><img src="https://images2018.cnblogs.com/blog/563799/201804/563799-20180424190147259-1583450039.png" alt="avatar"></p><h3 id="4-3-元空间OOM"><a href="#4-3-元空间OOM" class="headerlink" title="4.3 元空间OOM"></a>4.3 元空间OOM</h3><h3 id="4-4-直接内存OOM"><a href="#4-4-直接内存OOM" class="headerlink" title="4.4 直接内存OOM"></a>4.4 直接内存OOM</h3><h3 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5 参考资料"></a>5 参考资料</h3><p>深入理解Java虚拟机：JVM高级特性与最佳实践（第二版）</p><p>　</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载机制</title>
      <link href="2020/06/11/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>2020/06/11/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="1、什么是类的加载"><a href="#1、什么是类的加载" class="headerlink" title="1、什么是类的加载"></a>1、什么是类的加载</h3><p>&emsp;&emsp;类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的<strong>方法区</strong>内，然后在<strong>堆</strong>区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的 Class对象， Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p><p><img src="https://images2015.cnblogs.com/blog/331425/201606/331425-20160621125941772-1913742708.png" alt="avatar"></p><p>&emsp;&emsp;类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误</p><p>####加载.class文件的方式</p><ul><li><p>从本地系统中直接加载</p></li><li><p>通过网络下载.class文件</p></li><li><p>从zip，jar等归档文件中加载.class文件</p></li><li><p>从专有数据库中提取.class文件</p></li><li><p>将Java源文件动态编译为.class文件</p></li></ul><h3 id="2、类的生命周期"><a href="#2、类的生命周期" class="headerlink" title="2、类的生命周期"></a>2、类的生命周期</h3><p><img src="https://images2015.cnblogs.com/blog/331425/201606/331425-20160621125943209-1443333281.png" alt="avatar"></p><p>&emsp;&emsp;其中类加载的过程包括了<font color=#0099ff face="黑体">加载、验证、准备、解析、初始化</font>  五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>&emsp;&emsp;查找并加载类的二进制数据加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p><ol><li><p>通过一个类的全限定名来获取其定义的二进制字节流。</p></li><li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p></li><li><p>在Java堆中生成一个代表这个类的 java.lang.Class对象，作为对方法区中这些数据的访问入口。</p></li></ol><p>&emsp;&emsp;相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><p>&emsp;&emsp;加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。</p><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p><strong>验证：确保被加载的类的正确性</strong></p><p>&emsp;&emsp;验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p><p><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范；例如：是否以 0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</p><p><strong>元数据验证</strong>：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object之外。</p><p><strong>字节码验证</strong>：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p><p><strong>符号引用验证</strong>：确保解析动作能正确执行。</p><p>&emsp;&emsp;验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><p><strong>准备：为类的</strong> 静态变量分<strong>配内存，并将其初始化为默认值</strong></p><p>&emsp;&emsp;准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p><ul><li><p>1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</p></li><li><p>2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</p></li></ul><p>&emsp;&emsp;假设一个类变量的定义为： <code>publicstaticintvalue=3；</code></p><p>&emsp;&emsp;那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的 publicstatic指令是在程序编译后，存放于类构造器 <clinit>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</p><blockquote><p>这里还需要注意如下几点：</p></blockquote><blockquote><ul><li>对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li></ul></blockquote><blockquote><ul><li>对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li></ul></blockquote><blockquote><ul><li>对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。</li></ul></blockquote><blockquote><ul><li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li></ul></blockquote><p>3、如果类字段的字段属性表中存在 <code>ConstantValue</code>属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。</p><p>假设上面的类变量value被定义为： <code>publicstaticfinalintvalue=3；</code></p><p>&emsp;&emsp;编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据 ConstantValue的设置将value赋值为3。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中</p><p><strong>解析：把类中的符号引用转换为直接引用</strong></p><p>&emsp;&emsp;解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p><p>&emsp;&emsp;直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><p><strong>初始化</strong></p><p>&emsp;&emsp;初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p><ul><li><p>①声明类变量是指定初始值</p></li><li><p>②使用静态代码块为类变量指定初始值</p></li></ul><p>JVM初始化步骤</p><ul><li><p>1、假如这个类还没有被加载和连接，则程序先加载并连接该类</p></li><li><p>2、假如该类的直接父类还没有被初始化，则先初始化其直接父类</p></li><li><p>3、假如类中有初始化语句，则系统依次执行这些初始化语句</p></li></ul><p>&emsp;&emsp;类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p><ul><li><p>创建类的实例，也就是new的方式</p></li><li><p>访问某个类或接口的静态变量，或者对该静态变量赋值</p></li><li><p>调用类的静态方法</p></li><li><p>反射（如 Class.forName(“com.shengsiyuan.Test”)）</p></li><li><p>初始化某个类的子类，则其父类也会被初始化</p></li><li><p>Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类</p></li></ul><p><strong>结束生命周期</strong></p><p>&emsp;&emsp;在如下几种情况下，Java虚拟机将结束生命周期</p><ul><li><p>执行了 <code>System.exit()</code>方法</p></li><li><p>程序正常执行结束</p></li><li><p>程序在执行过程中遇到了异常或错误而异常终止</p></li><li><p>由于操作系统出现错误而导致Java虚拟机进程终止</p></li></ul><p><strong>3、类加载器</strong><br>寻找类加载器，先来一个小例子</p><pre><code>``` package com.neo.classloader; public class ClassLoaderTest&#123;   public static void main(String[] args)&#123;      ClassLoader loader = Thread.currentThread().getContextClassLoader();      System.out.printIn(loader);      System.out.printIn(loader.getParent());      System.out.printIn(loader.getParent().getParent());   &#125; &#125;​```</code></pre><p>运行后，输出结果：</p><pre><code>``` sun.misc.Launcher$AppClassLoader@64fef26a sun.misc.Launcher$ExtClassLoader@1ddd40f3 null ```</code></pre><p>&emsp;&emsp;从上面的结果可以看出，并没有获取到 ExtClassLoader的父Loader，原因是 BootstrapLoader（引导类加载器）是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回null。</p><p>&emsp;&emsp;这几种类加载器的层次关系如下图所示：</p><p><img src="https://images2015.cnblogs.com/blog/331425/201606/331425-20160621125944459-1013316302.jpg" alt="avatar"></p><blockquote><p>注意：这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。</p></blockquote><p>&emsp;&emsp;站在Java虚拟机的角度来讲，只存在两种不同的类加载器：启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；所有其它的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类 <code>java.lang.ClassLoader</code>，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p><p>&emsp;&emsp;站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</p><p><strong>启动类加载器：</strong> BootstrapClassLoader，负责加载存放在 JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被 -Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被 BootstrapClassLoader加载）。启动类加载器是无法被Java程序直接引用的。</p><p><strong>扩展类加载器：</strong> ExtensionClassLoader，该加载器由 sun.misc.Launcher$ExtClassLoader实现，它负责加载 JDK\jre\lib\ext目录中，或者由 java.ext.dirs系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。</p><p><strong>应用程序类加载器：</strong> ApplicationClassLoader，该类加载器由 sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><p>&emsp;&emsp;应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p><ul><li><p>1、在执行非置信代码之前，自动验证数字签名。</p></li><li><p>2、动态地创建符合用户特定需要的定制化构建类。</p></li><li><p>3、从特定的场所取得java class，例如数据库中和网络中。</p></li></ul><p>JVM类加载机制</p><ul><li><p><strong>全盘负责</strong>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p></li><li><p><strong>父类委托</strong>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p></li><li><p><strong>缓存机制</strong>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p></li></ul><p><strong>4、类的加载</strong><br>类加载有三种方式：</p><p>1、命令行启动应用时候由JVM初始化加载</p><p>2、通过Class.forName()方法动态加载</p><p>3、通过ClassLoader.loadClass()方法动态加载</p><p><strong>Class.forName()和ClassLoader.loadClass()区别</strong></p><ul><li><p><code>Class.forName()</code>：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</p></li><li><p><code>ClassLoader.loadClass()</code>：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</p></li><li><p><code>Class.forName(name,initialize,loader)</code>带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。</p></li></ul><p><strong>5、双亲委派模型</strong></p><p>&emsp;&emsp;双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p><p>双亲委派机制:</p><p>1、当 <code>AppClassLoader</code>加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</p><p>2、当 <code>ExtClassLoader</code>加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader```去完成。</p><p>3、如果 <code>BootStrapClassLoader</code>加载失败（例如在 <code>$JAVA_HOME/jre/lib</code>里未查找到该class），会使用 ExtClassLoader来尝试加载；</p><p>4、若ExtClassLoader也加载失败，则会使用 <code>AppClassLoader</code>来加载，如果 <code>AppClassLoader</code>也加载失败，则会报出异常 <code>ClassNotFoundException</code>。</p><p>双亲委派模型意义：</p><ul><li><p>系统类防止内存中出现多份同样的字节码</p></li><li><p>保证Java程序安全稳定运行</p></li></ul><p><strong>6、自定义类加载器</strong></p><p>&emsp;&emsp;通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自 ClassLoader类，从上面对 loadClass方法来分析来看，我们只需要重写 findClass 方法即可。</p><p>&emsp;&emsp;自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，我并未对class文件进行加密，因此没有解密的过程。这里有几点需要注意：</p><ul><li><p>1、这里传递的文件名需要是类的全限定性名称，即 <code>com.paddx.test.classloading.Test</code>格式的，因为 defineClass 方法是按这种格式进行处理的。</p></li><li><p>2、最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。</p></li><li><p>3、这类Test 类本身可以被 <code>AppClassLoader</code>类加载，因此我们不能把 <code>com/paddx/test/classloading/Test.class</code>放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由 AppClassLoader加载，而不会通过我们自定义类加载器来加载。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
